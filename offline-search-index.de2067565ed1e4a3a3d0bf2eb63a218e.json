


















































































































[{"body":"題目 傳入 數字列表 及 最後答案加總數值，回傳 最後答案加總數值 是 數字列表 的第幾個跟第幾個數字的加總\n答案 func twoSum(nums_list []int, final_sum_value int) []int { // 數字反向對應表 \tnum_reverse_mapping := make(map[int]int) for key, value := range nums_list { // 判斷是否其他數值存在 \tif other_value_key, is_other_value_exist := num_reverse_mapping[final_sum_value-value]; is_other_value_exist { // 回傳其他數值鍵值 + 目前數值鍵值 \treturn []int{other_value_key, key} } // 設定數值反向對應表：數值 =\u003e 鍵值 \tnum_reverse_mapping[value] = key } return nil } 完整程式碼 package main import ( \"fmt\" ) type question struct { // 參數 \tparameter // 答案 \tanswer } // 參數 type parameter struct { nums_list []int final_sum_value int } // 答案 type answer struct { one []int } func main() { question_list := []question{ { parameter{[]int{3, 2, 4}, 6}, answer{[]int{1, 2}}, }, { parameter{[]int{3, 2, 4}, 5}, answer{[]int{0, 1}}, }, { parameter{[]int{0, 8, 7, 3, 3, 4, 2}, 11}, answer{[]int{1, 3}}, }, { parameter{[]int{0, 1}, 1}, answer{[]int{0, 1}}, }, { parameter{[]int{0, 3}, 5}, answer{[]int{}}, }, } fmt.Printf(\"------------------------Leetcode Problem 1------------------------\\n\") for _, question := range question_list { // _, p := question.answer, question.parameter \tparam := question.parameter fmt.Printf(\"【input】:%v 【output】:%v\\n\", param, twoSum(param.nums_list, param.final_sum_value)) } } func twoSum(nums_list []int, final_sum_value int) []int { // 數字反向對應表 \tnum_reverse_mapping := make(map[int]int) for key, value := range nums_list { // 判斷是否其他數值存在 \tif other_value_key, is_other_value_exist := num_reverse_mapping[final_sum_value-value]; is_other_value_exist { // 回傳其他數值鍵值 + 目前數值鍵值 \treturn []int{other_value_key, key} } // 設定數值反向對應表：數值 =\u003e 鍵值 \tnum_reverse_mapping[value] = key } return nil } 參考資料  Two Sum - LeetCode 0001. Two Sum | LeetCode Cookbook  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0001 - Two Sum"],"description":"Golang Leetcode 問題: 0001 - Two Sum","excerpt":"Golang Leetcode 問題: 0001 - Two Sum","ref":"/leetcode/question/0001-0100/0001-two-sum/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0001 - Two Sum"],"title":"0001 - Two Sum"},{"body":"題目 傳入 數字列表 及 最後答案加總數值，回傳 最後答案加總數值 是 數字列表 的第幾個跟第幾個數字的加總\n答案 func addTwoNumbers(FirstNumberListNode *ListNode, SecondNumberListNode *ListNode) *ListNode { AnswerListNode := \u0026ListNode{Val: 0} // 建立答案節點，預設個位數是 0 \tCurrentAnswerListNode := AnswerListNode // 目前答案節點 \tnumber_1 := 0 // 第 1 個加總數值 \tnumber_2 := 0 // 第 2 個加總數值 \tcarry_number := 0 // 加總後的進位數值 \tnumber_sum := 0 // 加總數值  // 若「第 1 數字節點」或「第 2 數字節點」有資料不為 nil 時，或沒有任何進位數字時 \tfor FirstNumberListNode != nil || SecondNumberListNode != nil || carry_number != 0 { // 判斷「第 1 數字節點」 \tif FirstNumberListNode == nil { // 若「第 1 數字節點」為 nil，表示沒有數字可以做加總了，設定可加總數字為 0 \tnumber_1 = 0 } else { // 若「第 1 數字節點」有值，將節點數值設定為此次第 1 個加總數值 \tnumber_1 = FirstNumberListNode.Val FirstNumberListNode = FirstNumberListNode.Next } // 判斷「第 2 數字節點」 \tif SecondNumberListNode == nil { // 若「第 2 數字節點」為 nil，表示沒有數字可以做加總了，設定可加總數字為 0 \tnumber_2 = 0 } else { // 若「第 1 數字節點」有值，將節點數值設定為此次第 2 個加總數值 \tnumber_2 = SecondNumberListNode.Val SecondNumberListNode = SecondNumberListNode.Next } // 加總數值 \tnumber_sum = (number_1 + number_2 + carry_number) // 設定餘數為目前答案節點數值 \tCurrentAnswerListNode.Next = \u0026ListNode{Val: number_sum % 10} // 設定答案節點的下一節點為目前節點，繼續往後做加總 \tCurrentAnswerListNode = CurrentAnswerListNode.Next // 取得加總後的進位數值，繼續往後做加總 \tcarry_number = number_sum / 10 } return AnswerListNode.Next } 完整程式碼 package main import ( \"fmt\" ) // ListNode define type ListNode struct { Val int Next *ListNode } // 問題 type question struct { parameter answer } // para 是参数 // one 代表第一个参数 type parameter struct { one []int another []int } // ans 是答案 // one 代表第一个答案 type answer struct { one []int } func main() { // 問題清單 \tquestion_list := []question{ { parameter{[]int{}, []int{}}, answer{[]int{}}, }, { parameter{[]int{1}, []int{1}}, answer{[]int{2}}, }, { parameter{[]int{1, 2, 3, 4}, []int{1, 2, 3, 4}}, answer{[]int{2, 4, 6, 8}}, }, { parameter{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}}, answer{[]int{2, 4, 6, 8, 0, 1}}, }, { parameter{[]int{1}, []int{9, 9, 9, 9, 9}}, answer{[]int{0, 0, 0, 0, 0, 1}}, }, { parameter{[]int{9, 9, 9, 9, 9}, []int{1}}, answer{[]int{0, 0, 0, 0, 0, 1}}, }, { parameter{[]int{2, 4, 3}, []int{5, 6, 4}}, answer{[]int{7, 0, 8}}, }, { parameter{[]int{1, 8, 3}, []int{7, 1}}, answer{[]int{8, 9, 3}}, }, } fmt.Printf(\"------------------------Leetcode Problem 2------------------------\\n\") for _, question := range question_list { param := question.parameter fmt.Printf(\"【input】:%v 【output】:%v\\n\", param, List2Ints(addTwoNumbers(Ints2List(param.one), Ints2List(param.another)))) } fmt.Printf(\"\\n\\n\\n\") } // 連結數字相加 func addTwoNumbers(FirstNumberListNode *ListNode, SecondNumberListNode *ListNode) *ListNode { AnswerListNode := \u0026ListNode{Val: 0} // 建立答案節點，預設個位數是 0 \tCurrentAnswerListNode := AnswerListNode // 目前答案節點 \tnumber_1 := 0 // 第 1 個加總數值 \tnumber_2 := 0 // 第 2 個加總數值 \tcarry_number := 0 // 加總後的進位數值 \tnumber_sum := 0 // 加總數值  // 若「第 1 數字節點」或「第 2 數字節點」有資料不為 nil 時，或沒有任何進位數字時 \tfor FirstNumberListNode != nil || SecondNumberListNode != nil || carry_number != 0 { // 判斷「第 1 數字節點」 \tif FirstNumberListNode == nil { // 若「第 1 數字節點」為 nil，表示沒有數字可以做加總了，設定可加總數字為 0 \tnumber_1 = 0 } else { // 若「第 1 數字節點」有值，將節點數值設定為此次第 1 個加總數值 \tnumber_1 = FirstNumberListNode.Val FirstNumberListNode = FirstNumberListNode.Next } // 判斷「第 2 數字節點」 \tif SecondNumberListNode == nil { // 若「第 2 數字節點」為 nil，表示沒有數字可以做加總了，設定可加總數字為 0 \tnumber_2 = 0 } else { // 若「第 1 數字節點」有值，將節點數值設定為此次第 2 個加總數值 \tnumber_2 = SecondNumberListNode.Val SecondNumberListNode = SecondNumberListNode.Next } // 加總數值 \tnumber_sum = (number_1 + number_2 + carry_number) // 設定餘數為目前答案節點數值 \tCurrentAnswerListNode.Next = \u0026ListNode{Val: number_sum % 10} // 設定答案節點的下一節點為目前節點，繼續往後做加總 \tCurrentAnswerListNode = CurrentAnswerListNode.Next // 取得加總後的進位數值，繼續往後做加總 \tcarry_number = number_sum / 10 } return AnswerListNode.Next } // 鏈結清單轉換成整數陣列 func List2Ints(HeadListNode *ListNode) []int { // 鏈結深度限制，鏈結深度超過限制會出錯 \tlink_list_depth_limit := 100 current_link_list_depth := 0 res := []int{} for HeadListNode != nil { // 若有連結資料 \tcurrent_link_list_depth++ if current_link_list_depth \u003e link_list_depth_limit { msg := fmt.Sprintf(\"鏈結深度超過%d，可能出现環狀鏈結。檢查錯誤，或者調整 List2Ints 函式中 link_list_depth_limit 的限制。\", link_list_depth_limit) panic(msg) } res = append(res, HeadListNode.Val) HeadListNode = HeadListNode.Next } return res } // Ints2List convert []int to List // 整數陣列轉換成鏈結清單 func Ints2List(nums_list []int) *ListNode { if len(nums_list) == 0 { return nil } // 初始化鏈結節點 \tHeadListNode := \u0026ListNode{} // 設定目前鏈結節點 \tCurrentListNode := HeadListNode for _, number := range nums_list { // 設定鏈結節點的下一節點 \tCurrentListNode.Next = \u0026ListNode{Val: number} // 將下一節點設為目前節點 \tCurrentListNode = CurrentListNode.Next } return HeadListNode.Next } 參考資料  Two Sum - LeetCode 0001. Two Sum | LeetCode Cookbook  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0002 - Add Two Number"],"description":"Golang Leetcode 問題: 0002 - Add Two Number","excerpt":"Golang Leetcode 問題: 0002 - Add Two Number","ref":"/leetcode/question/0001-0100/0002-add-two-number/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0002 - Add Two Number"],"title":"0002 - Add Two Number"},{"body":"題目  Given a string s, find the length of the longest substring without repeating characters.\n 傳入 字串變數 ，找出 最長的子字串字元 長度\n答案 1. 解法1 使用 bit func lengthOfLongestSubstring1(check_text string) int { // 被檢查的文字長度 \tcheck_text_length := len(check_text) if check_text_length == 0 { // 驗證字串長度為 0 不檢查 \treturn 0 } // 文字 ASCII 檢查設定，預設都沒有找到此文字 false \tvar text_ascii_bit_set [256]bool // 右方指標字元 ASCII Code \tvar right_character_ascii_code uint8 // 左方指標字元 ASCII Code \tvar left_character_ascii_code uint8 // 左方字元索引 \tleft_character_index := 0 // 右方字元索引 \tright_character_index := 0 // 檢查文字最大不重複字串長度 \tcheck_text_longest_string_length := 0 // 目前字串長度 \tcurrent_text_string_length := 0 for left_character_index \u003c check_text_length { // 左側字元索引小於檢查字串長度，還沒有全部檢查完，繼續檢查  // 右方指標字元 ASCII Code \tright_character_ascii_code = check_text[right_character_index] // 左方指標字元 ASCII Code \tleft_character_ascii_code = check_text[left_character_index] if text_ascii_bit_set[right_character_ascii_code] { // 若右方文字已經有出現過，表示從左方索引到右方索引中間已經有出現過該文字 \t// 左方文字設定為未出現過 false \ttext_ascii_bit_set[left_character_ascii_code] = false // 左方往右推進 1 個字元，繼續檢查搜尋 \tleft_character_index++ } else { // 右方文字沒有出現過，設定右方文字為已出現過 true \ttext_ascii_bit_set[right_character_ascii_code] = true // 右方指標往前搜尋 \tright_character_index++ } // 設定目前字串長度 \tcurrent_text_string_length = right_character_index - left_character_index if check_text_longest_string_length \u003c current_text_string_length { // 若右方指標在左方指標前面，且長度大於目前檢查文字的最大長度，將目前長度設定為最大長度 \tcheck_text_longest_string_length = current_text_string_length } if left_character_index+check_text_longest_string_length \u003e= check_text_length || right_character_index \u003e= check_text_length { // 1. 左方字元索引 + 目前檢查文字的最大長度 \u003e 文字最大長度：再往右找也找不到更長的文字了 \t// 2. 右方字元索引 \u003e= 被檢查的文字長度 : 已經檢查到最後一個字元了 \t// 跳出檢查 \tbreak } } return check_text_longest_string_length } 2. 解法2 使用 sliding window func lengthOfLongestSubstring(check_text string) int { // 被檢查的文字長度 \tcheck_text_length := len(check_text) if check_text_length == 0 { // 驗證字串長度為 0 不檢查 \treturn 0 } // 建立長度 256 的整數陣列 \tvar text_ascii_int_flag [256]int // 左方字元索引 \tleft_character_index := 0 // 右方字元索引 \tright_character_index := 0 // 檢查文字最大不重複字串長度 \tcheck_text_longest_string_length := 0 // 右方指標字元 ASCII Code \tvar right_character_ascii_code uint8 // 左方指標字元 ASCII Code \tvar left_character_ascii_code uint8 // 目前字串長度 \tcurrent_text_string_length := 0 for left_character_index \u003c check_text_length { // 若左側指標小於字串長度，繼續檢查 \tif right_character_index \u003e= check_text_length { // 若右側指標大於字串長度，表示已經檢查到最後的字串了，不需要再檢查 \tbreak } // 右方指標字元 ASCII Code \tright_character_ascii_code = check_text[right_character_index] if text_ascii_int_flag[right_character_ascii_code] == 0 { // 「右側指標 +1 小於字串長度，表示字串還沒全部檢查完」且「此文字未出現過」 \t// 標記右方文字出現過 \ttext_ascii_int_flag[right_character_ascii_code] = 1 // 繼續往右檢查 \tright_character_index++ } else { // 左方指標字元 ASCII Code \tleft_character_ascii_code = check_text[left_character_index] // 標記左方文字沒出現過 \ttext_ascii_int_flag[left_character_ascii_code] = 0 // 將左方指標往前移動 \tleft_character_index++ } // 設定目前字串長度 \tcurrent_text_string_length = right_character_index - left_character_index if check_text_longest_string_length \u003c current_text_string_length { // 若右方指標在左方指標前面，且長度大於目前檢查文字的最大長度，將目前長度設定為最大長度 \tcheck_text_longest_string_length = current_text_string_length } } return check_text_longest_string_length } 完整程式碼 package main import ( \"fmt\" ) type QuestionList struct { Parameter Answer } // Parameter 是参数 // check_text 代表檢查的字串 type Parameter struct { check_text string } // Answer 是答案 // one 代表第一个答案 type Answer struct { one int } func main() { question_list := []QuestionList{ { Parameter{\"abcabcbb\"}, Answer{3}, }, { Parameter{\"bbbbb\"}, Answer{1}, }, { Parameter{\"pwwkew\"}, Answer{3}, }, { Parameter{\"\"}, Answer{0}, }, } fmt.Printf(\"------------------------Leetcode Problem 3------------------------\\n\") for _, question := range question_list { // 問題參數 \tParam := question.Parameter fmt.Printf(\"solution 1【input】:%v 【output】:%v\\n\", Param, lengthOfLongestSubstring1(Param.check_text)) fmt.Printf(\"solution 2【input】:%v 【output】:%v\\n\", Param, lengthOfLongestSubstring2(Param.check_text)) } fmt.Printf(\"\\n\\n\\n\") } // 解法1 使用 bit func lengthOfLongestSubstring1(check_text string) int { // 被檢查的文字長度 \tcheck_text_length := len(check_text) if check_text_length == 0 { // 驗證字串長度為 0 不檢查 \treturn 0 } // 文字 ASCII 檢查設定，預設都沒有找到此文字 false \tvar text_ascii_bit_set [256]bool // 右方指標字元 ASCII Code \tvar right_character_ascii_code uint8 // 左方指標字元 ASCII Code \tvar left_character_ascii_code uint8 // 左方字元索引 \tleft_character_index := 0 // 右方字元索引 \tright_character_index := 0 // 檢查文字最大不重複字串長度 \tcheck_text_longest_string_length := 0 // 目前字串長度 \tcurrent_text_string_length := 0 for left_character_index \u003c check_text_length { // 左側字元索引小於檢查字串長度，還沒有全部檢查完，繼續檢查  // 右方指標字元 ASCII Code \tright_character_ascii_code = check_text[right_character_index] // 左方指標字元 ASCII Code \tleft_character_ascii_code = check_text[left_character_index] if text_ascii_bit_set[right_character_ascii_code] { // 若右方文字已經有出現過，表示從左方索引到右方索引中間已經有出現過該文字 \t// 左方文字設定為未出現過 false \ttext_ascii_bit_set[left_character_ascii_code] = false // 左方往右推進 1 個字元，繼續檢查搜尋 \tleft_character_index++ } else { // 右方文字沒有出現過，設定右方文字為已出現過 true \ttext_ascii_bit_set[right_character_ascii_code] = true // 右方指標往前搜尋 \tright_character_index++ } // 設定目前字串長度 \tcurrent_text_string_length = right_character_index - left_character_index if check_text_longest_string_length \u003c current_text_string_length { // 若右方指標在左方指標前面，且長度大於目前檢查文字的最大長度，將目前長度設定為最大長度 \tcheck_text_longest_string_length = current_text_string_length } if left_character_index+check_text_longest_string_length \u003e= check_text_length || right_character_index \u003e= check_text_length { // 1. 左方字元索引 + 目前檢查文字的最大長度 \u003e 文字最大長度：再往右找也找不到更長的文字了 \t// 2. 右方字元索引 \u003e= 被檢查的文字長度 : 已經檢查到最後一個字元了 \t// 跳出檢查 \tbreak } } return check_text_longest_string_length } // 解法2 Sliding Window func lengthOfLongestSubstring2(check_text string) int { // 被檢查的文字長度 \tcheck_text_length := len(check_text) if check_text_length == 0 { // 驗證字串長度為 0 不檢查 \treturn 0 } // 建立長度 256 的整數陣列 \tvar text_ascii_int_flag [256]int // 左方字元索引 \tleft_character_index := 0 // 右方字元索引 \tright_character_index := 0 // 檢查文字最大不重複字串長度 \tcheck_text_longest_string_length := 0 // 右方指標字元 ASCII Code \tvar right_character_ascii_code uint8 // 左方指標字元 ASCII Code \tvar left_character_ascii_code uint8 // 目前字串長度 \tcurrent_text_string_length := 0 for left_character_index \u003c check_text_length { // 若左側指標小於字串長度，繼續檢查 \tif right_character_index \u003e= check_text_length { // 若右側指標大於字串長度，表示已經檢查到最後的字串了，不需要再檢查 \tbreak } // 右方指標字元 ASCII Code \tright_character_ascii_code = check_text[right_character_index] if text_ascii_int_flag[right_character_ascii_code] == 0 { // 「右側指標 +1 小於字串長度，表示字串還沒全部檢查完」且「此文字未出現過」 \t// 標記右方文字出現過 \ttext_ascii_int_flag[right_character_ascii_code] = 1 // 繼續往右檢查 \tright_character_index++ } else { // 左方指標字元 ASCII Code \tleft_character_ascii_code = check_text[left_character_index] // 標記左方文字沒出現過 \ttext_ascii_int_flag[left_character_ascii_code] = 0 // 將左方指標往前移動 \tleft_character_index++ } // 設定目前字串長度 \tcurrent_text_string_length = right_character_index - left_character_index if check_text_longest_string_length \u003c current_text_string_length { // 若右方指標在左方指標前面，且長度大於目前檢查文字的最大長度，將目前長度設定為最大長度 \tcheck_text_longest_string_length = current_text_string_length } } return check_text_longest_string_length } 參考資料  Longest Substring Without Repeating Characters - LeetCode 0003. Longest Substring Without Repeating Characters | LeetCode Cookbook  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0003 - Longest Substring Without Repeating Characters"],"description":"Golang Leetcode 問題: 0003 - Longest Substring Without Repeating Characters","excerpt":"Golang Leetcode 問題: 0003 - Longest Substring Without Repeating Characters","ref":"/leetcode/question/0001-0100/0003-longest-substring-without-repeating-characters/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0003 - Longest Substring Without Repeating Characters"],"title":"0003 - Longest Substring Without Repeating Characters"},{"body":"題目  Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n  The overall run time complexity should be O(log (m+n)).\n 傳入 2 個已排序數字陣列，回傳兩個排序陣列的中位數，複雜度必須為 O(log (m+n)).\n演算法原理 Binary Search : Median of two sorted arrays of different sizes   答案 func findMedianSortedArrays(nums_list_1 []int, nums_list_2 []int) float64 { // 假设 nums1 的长度小  if len(nums_list_1) \u003e len(nums_list_2) { // 若數字清單 1 長度大於數字清單 2，將清單較短的數字清單 2 優先傳入第一個參數  return findMedianSortedArrays(nums_list_2, nums_list_1) } // 「數字清單 1」左方數字索引  num1_left_num_index := 0 // 「數字清單 1」右方數字索引  num1_right_nums_index := len(nums_list_1) // 所有數字中位數可能位置，全部長度+1，bit 往右位移除 2  all_nums_list_divide_position := (len(nums_list_1) + len(nums_list_2) + 1) \u003e\u003e 1 // 「數字清單 1」中位數位置  nums1_median_index := 0 // 「數字清單 2」中位數位置  nums2_median_index := 0 // === 中位數區塊劃分 ===  for num1_left_num_index \u003c= num1_right_nums_index { // 「當左方數字索引」比「右方數字索引」還要小，表示搜尋的數字還沒交叉重複到  // 數字清單 1 中位數位置 = 目前左方最小數字位置 + 右方剩餘數字取中位數 bit 往右位移(除 2)  // 中位數分界點，左側是 median_index -1，右側是 median_index，  // nums1: ……………… nums1[nums1_median_index-1] | nums1[nums1_median_index] ……………………  // nums2: ……………… nums2[nums2_median_index-1] | nums2[nums2_median_index] ……………………  nums1_median_index = num1_left_num_index + (num1_right_nums_index-num1_left_num_index)\u003e\u003e1 // 數字清單 2 中位數位置 = 所有數字中位數可能位置 - 數字清單 1 中位數位置  nums2_median_index = all_nums_list_divide_position - nums1_median_index if nums1_median_index \u003e 0 \u0026\u0026 nums_list_1[nums1_median_index-1] \u003e nums_list_2[nums2_median_index] { // nums1 中的分界线划多了，要向左边移动  // 「數字清單 1」中位數位置不是第一個數字  // 「數字清單 1」中位數左側數字比「數字清單 2」右側中位數還大（排序過的數字左側應比右側小）  // 表示整個數字列表的中位數在「數字清單 1」目前中位數之前  // 「數字清單 1」右方數字索引往左側移動，找「數字清單 1」中位數前面小一點的數字  num1_right_nums_index = nums1_median_index - 1 } else if nums1_median_index != len(nums_list_1) \u0026\u0026 nums_list_1[nums1_median_index] \u003c nums_list_2[nums2_median_index-1] { // nums1 中的分界线划少了，要向右边移动  // 「數字清單 1」中位數位置不是最後一個數字  // 「數字清單 1」中位數右側數字比「數字清單 2」左側中位數還小（排序過的數字右側應比左側大）  // 「數字清單 1」中位數位置數字 比 「數字清單 2」中位數位位置的前一個數字還小  // 「數字清單 1」左方數字索引往右側移動，找「數字清單 1」中位數後面大一點的數字  num1_left_num_index = nums1_median_index + 1 } else { // 無法再劃分左右側中位數位置  break } } // === 找出中位數 ===  // 中位數  var median_num float64 = 0.0 // 左側中位數  median_num_left := 0 // 右側中位數  median_num_right := 0 if nums1_median_index == 0 { // 「數字清單 1」中位數位置為第一個數字  // 中位數左側數字 = 「數字清單 2」 左側第一個數字」  median_num_left = nums_list_2[nums2_median_index-1] } else if nums2_median_index == 0 { // 「數字清單 2」中位數位置為第一個數字  // 中位數左側數字 = 「數字清單 1」 左側第一個數字」  median_num_left = nums_list_1[nums1_median_index-1] } else { // 中位數左側數字 = 「數字清單 1 左側位置第一個數字」與「數字清單 2 左側位置第一個數字」取最大的數字  // 左側的數字比右側小，所以要找比較大的數字才會接近右側數字  median_num_left = max(nums_list_1[nums1_median_index-1], nums_list_2[nums2_median_index-1]) } // 判斷數字數量是奇數還是偶數  if (len(nums_list_1)+len(nums_list_2))\u00261 == 1 { // 若數字總數量為奇數，直接回傳中位數數字  median_num = float64(median_num_left) return median_num } if nums1_median_index == len(nums_list_1) { // 「數字清單 1」中位數位置在不在清單中，索引超出清單長度（索引從 0 開始算）  // 中位數右側數字 = 「數字清單 2」中位數右側第一個數字  median_num_right = nums_list_2[nums2_median_index] } else if nums2_median_index == len(nums_list_2) { // 「數字清單 2」中位數位置在不在清單中，索引超出清單長度（索引從 0 開始算）  // 中位數右側數字 = 「數字清單 1」中位數右側第一個數字  median_num_right = nums_list_1[nums1_median_index] fmt.Println(\"\u003cmedian_num_right (2)\u003e: num1_medium =\u003e nums_list_1[nums1_median_index]\") } else { // 中位數右側數字 = 「數字清單 1 右側第一個數字」與「數字清單 2 右側第一個數字」取最小的數字  // 右側的數字比左側大，所以要找比較小的數字才會接近左側數字  median_num_right = min(nums_list_1[nums1_median_index], nums_list_2[nums2_median_index]) } median_num = float64(median_num_left+median_num_right) / 2 return median_num } func max(a int, b int) int { if a \u003e b { return a } return b } func min(a int, b int) int { if a \u003e b { return b } return a } 完整程式碼 package main import ( \"fmt\" ) type QuestionList struct { Parameter Answer } // para 是参数 // one 代表第一个参数 type Parameter struct { nums1 []int nums2 []int } // ans 是答案 // one 代表第一个答案 type Answer struct { one float64 } func main() { question_list := []QuestionList{ { Parameter{[]int{400}, []int{111, 222, 333, 444, 555, 666, 777}}, Answer{422}, }, { Parameter{[]int{700}, []int{111, 222, 333, 444, 555, 666, 777}}, Answer{499.5}, }, { Parameter{[]int{600}, []int{111, 222, 333, 444, 555, 666, 777}}, Answer{499.5}, }, { Parameter{[]int{500}, []int{111, 222, 333, 444, 555, 666, 777}}, Answer{472}, }, { Parameter{[]int{1, 3, 5, 7, 9}, []int{2, 3, 4, 7, 11, 13}}, Answer{3.5}, }, { Parameter{[]int{1, 3}, []int{2}}, Answer{2.0}, }, { Parameter{[]int{1, 2}, []int{3, 4}}, Answer{2.5}, }, } fmt.Printf(\"------------------------Leetcode Problem 4------------------------\\n\") for _, question := range question_list { // 問題參數  Ans, Param := question.Answer, question.Parameter fmt.Printf(\"【input】:%+v answer:%+v 【output】:%+v\\n\", Param, Ans, findMedianSortedArrays(Param.nums1, Param.nums2)) } fmt.Printf(\"\\n\\n\\n\") } func findMedianSortedArrays(nums_list_1 []int, nums_list_2 []int) float64 { // 假设 nums1 的长度小  if len(nums_list_1) \u003e len(nums_list_2) { // 若數字清單 1 長度大於數字清單 2，將清單較短的數字清單 2 優先傳入第一個參數  return findMedianSortedArrays(nums_list_2, nums_list_1) } // 「數字清單 1」左方數字索引  num1_left_num_index := 0 // 「數字清單 1」右方數字索引  num1_right_nums_index := len(nums_list_1) // 所有數字中位數可能位置，全部長度+1，bit 往右位移除 2  all_nums_list_divide_position := (len(nums_list_1) + len(nums_list_2) + 1) \u003e\u003e 1 // 「數字清單 1」中位數位置  nums1_median_index := 0 // 「數字清單 2」中位數位置  nums2_median_index := 0 // === 中位數區塊劃分 ===  for num1_left_num_index \u003c= num1_right_nums_index { // 「當左方數字索引」比「右方數字索引」還要小，表示搜尋的數字還沒交叉重複到  // 數字清單 1 中位數位置 = 目前左方最小數字位置 + 右方剩餘數字取中位數 bit 往右位移(除 2)  // 中位數分界點，左側是 median_index -1，右側是 median_index，  // nums1: ……………… nums1[nums1_median_index-1] | nums1[nums1_median_index] ……………………  // nums2: ……………… nums2[nums2_median_index-1] | nums2[nums2_median_index] ……………………  nums1_median_index = num1_left_num_index + (num1_right_nums_index-num1_left_num_index)\u003e\u003e1 // 數字清單 2 中位數位置 = 所有數字中位數可能位置 - 數字清單 1 中位數位置  nums2_median_index = all_nums_list_divide_position - nums1_median_index if nums1_median_index \u003e 0 \u0026\u0026 nums_list_1[nums1_median_index-1] \u003e nums_list_2[nums2_median_index] { // nums1 中的分界线划多了，要向左边移动  // 「數字清單 1」中位數位置不是第一個數字  // 「數字清單 1」中位數左側數字比「數字清單 2」右側中位數還大（排序過的數字左側應比右側小）  // 表示整個數字列表的中位數在「數字清單 1」目前中位數之前  // 「數字清單 1」右方數字索引往左側移動，找「數字清單 1」中位數前面小一點的數字  num1_right_nums_index = nums1_median_index - 1 } else if nums1_median_index != len(nums_list_1) \u0026\u0026 nums_list_1[nums1_median_index] \u003c nums_list_2[nums2_median_index-1] { // nums1 中的分界线划少了，要向右边移动  // 「數字清單 1」中位數位置不是最後一個數字  // 「數字清單 1」中位數右側數字比「數字清單 2」左側中位數還小（排序過的數字右側應比左側大）  // 「數字清單 1」中位數位置數字 比 「數字清單 2」中位數位位置的前一個數字還小  // 「數字清單 1」左方數字索引往右側移動，找「數字清單 1」中位數後面大一點的數字  num1_left_num_index = nums1_median_index + 1 } else { // 無法再劃分左右側中位數位置  break } } // === 找出中位數 ===  // 中位數  var median_num float64 = 0.0 // 左側中位數  median_num_left := 0 // 右側中位數  median_num_right := 0 if nums1_median_index == 0 { // 「數字清單 1」中位數位置為第一個數字  // 中位數左側數字 = 「數字清單 2」 左側第一個數字」  median_num_left = nums_list_2[nums2_median_index-1] } else if nums2_median_index == 0 { // 「數字清單 2」中位數位置為第一個數字  // 中位數左側數字 = 「數字清單 1」 左側第一個數字」  median_num_left = nums_list_1[nums1_median_index-1] } else { // 中位數左側數字 = 「數字清單 1 左側位置第一個數字」與「數字清單 2 左側位置第一個數字」取最大的數字  // 左側的數字比右側小，所以要找比較大的數字才會接近右側數字  median_num_left = max(nums_list_1[nums1_median_index-1], nums_list_2[nums2_median_index-1]) } // 判斷數字數量是奇數還是偶數  if (len(nums_list_1)+len(nums_list_2))\u00261 == 1 { // 若數字總數量為奇數，直接回傳中位數數字  median_num = float64(median_num_left) return median_num } if nums1_median_index == len(nums_list_1) { // 「數字清單 1」中位數位置在不在清單中，索引超出清單長度（索引從 0 開始算）  // 中位數右側數字 = 「數字清單 2」中位數右側第一個數字  median_num_right = nums_list_2[nums2_median_index] } else if nums2_median_index == len(nums_list_2) { // 「數字清單 2」中位數位置在不在清單中，索引超出清單長度（索引從 0 開始算）  // 中位數右側數字 = 「數字清單 1」中位數右側第一個數字  median_num_right = nums_list_1[nums1_median_index] fmt.Println(\"\u003cmedian_num_right (2)\u003e: num1_medium =\u003e nums_list_1[nums1_median_index]\") } else { // 中位數右側數字 = 「數字清單 1 右側第一個數字」與「數字清單 2 右側第一個數字」取最小的數字  // 右側的數字比左側大，所以要找比較小的數字才會接近左側數字  median_num_right = min(nums_list_1[nums1_median_index], nums_list_2[nums2_median_index]) } median_num = float64(median_num_left+median_num_right) / 2 return median_num } func max(a int, b int) int { if a \u003e b { return a } return b } func min(a int, b int) int { if a \u003e b { return b } return a } 參考資料  Binary Search : Median of two sorted arrays of different sizes. - YouTube Median of Two Sorted Arrays - LeetCode 0004. Median of Two Sorted Arrays | LeetCode Cookbook  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0004 - Median of Two Sorted Arrays"],"description":"Golang Leetcode 問題: 0004 - Median of Two Sorted Arrays","excerpt":"Golang Leetcode 問題: 0004 - Median of Two Sorted Arrays","ref":"/leetcode/question/0001-0100/0004-median-of-two-sorted-arrays./","tags":["Golang","教學文件","新手教學","Leetcode","問題","0004 - Median of Two Sorted Arrays"],"title":"0004 - Median of Two Sorted Arrays"},{"body":"","categories":["Golang","教學文件","新手教學","Leetcode","問題"],"description":"Golang Leetcode 問題: 0001~0100","excerpt":"Golang Leetcode 問題: 0001~0100","ref":"/leetcode/question/0001-0100/","tags":["Golang","教學文件","新手教學","Leetcode","問題"],"title":"0001~0100"},{"body":"","categories":["Golang","教學文件","新手教學","Leetcode","問題"],"description":"Golang Leetcode 問題: 0101~0200","excerpt":"Golang Leetcode 問題: 0101~0200","ref":"/leetcode/question/0101-0200/","tags":["Golang","教學文件","新手教學","Leetcode","問題"],"title":"0101~0200"},{"body":"列印陣列 僅用到陣列 value 數值 nums := []int{2, 3, 4} sum := 0 for _, value := range nums { sum += value } fmt.Println(\"sum:\", sum) 列印陣列 key 及 value var name_list = []string{`Golang`, `Python`, `PHP`} for key, value := range name_list { fmt.Printf(\"language key: %d = %s\\n\", key, value) } // language key: 0 = Golang // language key: 1 = Python // language key: 2 = PHP arr1 := [3][2]int{{1, 2}, {3, 4}, {5, 6}} fmt.Println(arr1) // [[1 2] [3 4] [5 6]]  for key, value := range arr1 { fmt.Printf(\"%d =\u003e %d\\n\", key, value) } // 0 =\u003e [1 2] // 1 =\u003e [3 4] // 2 =\u003e [5 6] ","categories":["Golang","教學文件","新手教學","基礎","for range 迴圈"],"description":"Golang 基礎: for range 迴圈","excerpt":"Golang 基礎: for range 迴圈","ref":"/basic/loop/range/","tags":["Golang","教學文件","新手教學","基礎","for range 迴圈"],"title":"for range"},{"body":"for 一般迴圈 for j := 7; j \u003c= 9; j++ { fmt.Println(j) } // 7 // 8 // 9 for 外部設定初始值  有點類似 while 迴圈\n i := 1 for i \u003c= 3 { fmt.Println(i) i = i + 1 } // 1 // 2 // 3 for 無窮迴圈  若沒有 break 掉的話，會是無窮的迴圈，有點類似 while 迴圈\n for { fmt.Println(\"infinite loop\") break } ","categories":["Golang","教學文件","新手教學","基礎","for 迴圈"],"description":"Golang 基礎: for 迴圈","excerpt":"Golang 基礎: for 迴圈","ref":"/basic/loop/for/","tags":["Golang","教學文件","新手教學","基礎","for 迴圈"],"title":"for"},{"body":"一般變數宣告 一般變數宣告預設值 var num int = 0 var num int 一般變數宣告指定值 var num int = 10 var num = 10 單行宣告  應少用，程式碼可讀性不高\n var name, age, height = \"KJ\", 18, 199.9 多行宣告 var ( name = \"KJ\" age = 18 height = 199.9 ) 多行宣告加入型態 var ( name string = \"KJ\" age uint = 18 height float32 = 199.9 ) 多行宣告沒有設定預設值 var ( name string age uint height float32 ) 短變數宣告 name := \"KJ\" age := 18 height := 199.9 單行短變數宣告  應少用，程式碼可讀性不高\n name, age, height := \"KJ\", 18, 199.9 常數變數宣告 一般常數宣告 const AGE int = 18 單行常數宣告  應少用，程式碼可讀性不高\n const AUTHOR, AGE = \"KJ\", 18 多行常數宣告 const ( AUTHOR = \"KJ\" AGE = 18 ) 參考資料  Go by Example: Variables Go by Example: Constants  ","categories":["Golang","教學文件","新手教學","基礎","一般變數"],"description":"Golang 基礎: 一般變數","excerpt":"Golang 基礎: 一般變數","ref":"/basic/data-type/normal/","tags":["Golang","教學文件","新手教學","基礎","一般變數"],"title":"一般"},{"body":"跳脫字元    類型 說明     “雙引號” 可跳脫字元   `重音符` 保留原始字串    a := \"雙引號:可跳脫字元\\t \\n等\" b := `重音符:保留原始字串 \\t \\n 等` fmt.Println(a) fmt.Println(b) // 雙引號:可跳脫字元 // 等 // 重音符:保留原始字串 \\t \\n 等 列印函數 print    類型 說明 description     fmt.Print 列印 print   fmt.Println 列印 + 換行 print + new line   fmt.Printf 格式化列印(沒有換行) format print    fmt.Print 列印 a := `KJ` fmt.Print(a) fmt.Print(a) fmt.Print(a) // KJKJKJ fmt.Println 列印 + 換行 a := `KJ` fmt.Println(a) fmt.Println(a) fmt.Println(a) // KJ // KJ // KJ fmt.Printf 格式化列印 a := `KJ` fmt.Printf(\"a: %v type: %T\\n\", a, a) // a: KJ type: string 儲存列印字串 sprint    類型 說明 description     fmt.str2 儲存列印字串 save print string   fmt.Sprintln 儲存列印字串 + 換行 save print string + new line   fmt.Sprintf 儲存列印格式化字串(沒有換行) save format print string    fmt.Sprint 儲存列印字串 s1 := \"I\" s2 := \"am\" s3 := \"KJ\" str2 := fmt.Sprint(s1, s2, s3) fmt.Println(str2) // IamKJ fmt.Sprintln 儲存列印字串 + 換行  相鄰變數會用空格串接，字串最後會加上換行符號\n s1 := \"I\" s2 := \"am\" s3 := \"KJ\" // 將字串格式化儲存 str1 := fmt.Sprintln(s1, s2, s3) fmt.Println(str1) // I am KJ  fmt.Sprintf 儲存列印格式化字串 name := `KJ` age := 18 introduction := fmt.Sprintf(\"My name is %v. I'm %d years old\\n\", name, age) fmt.Printf(\"Developer said: %s\", introduction) // Developer said: My name is KJ. I'm 18 years old 參考資料  fmt - The Go Programming Language Println vs Printf vs Print in Go - Stack Overflow Go 学习笔记（46）— Go 标准库之 fmt（输入/输出格式化参数、Printf/Fprintf/Sprintf区别、Println/Fprintln/Sprintln 区别）_wohu1104的专栏-CSDN博客 # Day06 Go開教基本語法 (fmt) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天  ","categories":["Golang","教學文件","新手教學","基礎","列印"],"description":"Golang 基礎: 列印","excerpt":"Golang 基礎: 列印","ref":"/basic/print/","tags":["Golang","教學文件","新手教學","基礎","列印"],"title":"列印"},{"body":"一般    類型 說明 description     %v 預設格式 default format   %+v 預設格式加上欄位名稱 default format with field names   %#v golang 語法格式 Go-syntax format   %T golang 資料類型 Go-syntax type of value   %% 百分比符號 percent sign    預設格式 %v a := 26 fmt.Printf(\"a: %v\\n\", a) // a: 26 a := `KJ` fmt.Printf(\"a: %v\\n\", a) // a: KJ type Developer struct { name string age int is_working bool } func main() { fmt.Printf(\"Developer: %v\\n\", Developer{}) // Developer: { 0 false} } 預設格式加上欄位名稱 %+v type Developer struct { name string age int is_working bool } func main() { fmt.Printf(\"Developer: %+v\\n\", Developer{}) // Developer: {name: age:0 is_working:false} } golang 語法格式 %#v a := 26 fmt.Printf(\"a: %#v\\n\", a) // a: 26 a := `KJ` fmt.Printf(\"a: %#v\\n\", a) // a: \"KJ\" var a = []float64{1, 2, 4, 8, 16, 32, 64, 128} fmt.Printf(\"a: %#v\\n\", a) // a: []float64{1, 2, 4, 8, 16, 32, 64, 128} type Developer struct { name string age int is_working bool } func main() { fmt.Printf(\"Developer: %#v\\n\", Developer{}) // Developer: main.Developer{name:\"\", age:0, is_working:false} } golang 資料類型 %T var a = []float64{1, 2, 4, 8, 16, 32, 64, 128} fmt.Printf(\"a: %T\\n\", a) // a: []float64 a := 26 fmt.Printf(\"a: %T\\n\", a) // a: int a := `KJ` fmt.Printf(\"a: %T\\n\", a) // a: string 百分比符號 %% fmt.Printf(\"percent sign: %%\\n\") // percent sign: % 布林值    類型 說明 description     %t 布林值 true or false    布林值 %t a := true fmt.Printf(\"a: %t\\n\", a) // a: true a := 1 fmt.Printf(\"a: %t\\n\", a) // a: %!t(int=1) a := `KJ` fmt.Printf(\"a: %t\\n\", a) // a: %!t(string=KJ) 整數    類型 說明 description     %d 十進位數字 base 10   %b 二進位數字 base 2   %o 八進位數字 base 8   %O 八進位數字 base 8 with 0o prefix   %x 十六進位數字(小寫) base 16 with lower-case   %X 十六進位數字(大寫) base 16 with upper-case   %c 字元 ASCII 字元   %s 字串 一般字串   %U Unicode -    十進位數字 %d a := 10 fmt.Printf(\"a: %d\\n\", a) // a: 10 二進位數字 %b a := 10 fmt.Printf(\"a: %b\\n\", a) // a: 1010 八進位數字 %o %O a := 10 fmt.Printf(\"a: %o\\n\", a) // a: 12 a := 10 fmt.Printf(\"a: %O\\n\", a) // a: 0o12 十六進位數字 %x %X a := 26 fmt.Printf(\"a: %x\\n\", a) // a: 1a a := 26 fmt.Printf(\"a: %X\\n\", a) // a: 1A 字串 %s a := `KJ` fmt.Printf(\"a: %s\\n\", a) // a: KJ a := 75 fmt.Printf(\"a: %s\\n\", a) // a: %!s(int=75) ASCII 字元 %c a := 75 fmt.Printf(\"a: %c\\n\", a) // a: K Unicode 字元 %U a := 26 fmt.Printf(\"a: %U\\n\", a) // a: U+001A 參考資料  fmt - The Go Programming Language # Day06 Go開教基本語法 (fmt) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天  ","categories":["Golang","教學文件","新手教學","基礎","列印格式"],"description":"Golang 基礎: 列印格式","excerpt":"Golang 基礎: 列印格式","ref":"/basic/print/format/","tags":["Golang","教學文件","新手教學","基礎","列印格式"],"title":"格式"},{"body":"二進制位元運算\n運算符    運算符 簡述 說明     \u0026 AND 運算 要 全部 數值都為 1，運算後才為 1   | OR 運算 其中 一數值為 1，運算後才為 1   ^ XOR 運算 兩個數值不相同（0 or 1），運算後才為 1    運算範例 \u0026 : AND 運算  要 全部 數值都為 1，運算後才為 1\n    項目 數值 數值 數值 數值     bits_1 0 0 1 1   bits_2 0 1 0 1   bits_1 \u0026 bits_2 (AND 運算) 0 0 0 1    | : OR 運算  其中 一數值為 1，運算後才為 1\n    項目 數值 數值 數值 數值     bits_1 0 0 1 1   bits_2 0 1 0 1   bits_1 | bits_2 (OR 運算) 0 1 1 1    ^ : XOR 運算  兩個數值不相同（0 or 1），運算後才為 1\n    項目 數值 數值 數值 數值     bits_1 0 0 1 1   bits_2 0 1 0 1   bits_1 ^ bits_2 (XOR 運算) 0 1 1 0    ","categories":["Golang","教學文件","新手教學","基礎","運算元","Operators","位元 bits 運算"],"description":"Golang 基礎: 運算元 Operators 位元 bits 運算","excerpt":"Golang 基礎: 運算元 Operators 位元 bits 運算","ref":"/basic/operators/bits/","tags":["Golang","教學文件","新手教學","基礎","運算元","Operators","位元 bits 運算"],"title":"位元 bits 運算"},{"body":"陣列 指定陣列大小 var arr [5]int arr[0] = 1 arr[1] = 2 arr[4] = 5 fmt.Println(arr) // [1 2 0 0 5] arr := [5]int{1, 2, 3} fmt.Println(arr) // [1 2 3 0 0] 不指定陣列大小 arr := [...]int{1, 2, 3, 4, 5} fmt.Println(arr) // [1 2 3 4 5] 巢狀陣列 var arr [3][2]int fmt.Println(arr) // [[0 0] [0 0] [0 0]] 指定巢狀陣列預設值 arr1 := [3][2]int{{1, 2}, {3, 4}, {5, 6}} fmt.Println(arr1) // [[1 2] [3 4] [5 6]]  arr2 := [...][2]int{{1, 2}, {3, 4}, {5, 6}} fmt.Println(arr2) // [[1 2] [3 4] [5 6]] 複製陣列 限制陣列長度 arr := [5]int{1, 2, 3, 4, 5} // 指定要複製的陣列 var arr_copy [5]int arr_copy = arr arr_copy[3] = 99 fmt.Println(arr) // [1 2 3 4 5] fmt.Println(arr_copy) // [1 2 3 99 5] 不限制陣列長度  複製的陣列會變成傳址的方式\n arr := []int{1, 2, 3, 4, 5, 6, 7} var arr_copy []int arr_copy = arr arr_copy[3] = 99 fmt.Println(arr) // [1 2 3 99 5 6 7] fmt.Println(arr_copy) // [1 2 3 99 5 6 7] 參考資料  Go by Example: Arrays  ","categories":["Golang","教學文件","新手教學","基礎","陣列變數"],"description":"Golang 基礎: 陣列變數","excerpt":"Golang 基礎: 陣列變數","ref":"/basic/data-type/array/","tags":["Golang","教學文件","新手教學","基礎","陣列變數"],"title":"Array 陣列"},{"body":"","categories":["Golang","教學文件","新手教學","基礎"],"description":"Golang 基礎","excerpt":"Golang 基礎","ref":"/basic/","tags":["Golang","教學文件","新手教學","基礎"],"title":"基礎"},{"body":"整數    類型 min max 範圍     uint8 or byte 0 255 2^0 ~ 2^8   uint16 0 65585 2^0 ~ 2^16   uint32 or rune 0 4294967296 2^0 ~ 2^32   uint64 0 1.84467E+19 2^0 ~ 2^64   int8 -128 128 - 1 -2^7 ~ 2^7 - 1   int16 -32768 32768 - 1 -2^15 ~ 2^15 - 1   int32 -2147483648 2147483648 - 1 -2^31 ~ 2^31 - 1   int64 -9.22337E+18 9.22337E+18 - 1 -2^63 ~ 2^63 - 1    浮點數    類型 min max 範圍     float32 - - -1.410^-45 ~ 3.410^38   float64 - - -4.9410^-324 ~ 1.7910^308    參考資料  [Golang] 程式設計教學：資料型態 (Data Type) | Michael Chen 的技術文件  ","categories":["Golang","教學文件","新手教學","基礎","變數類型"],"description":"Golang 基礎: 變數類型","excerpt":"Golang 基礎: 變數類型","ref":"/basic/data-type/","tags":["Golang","教學文件","新手教學","基礎","變數類型"],"title":"變數類型"},{"body":"建立 slice 變數 employee_list := make([]string, 3) fmt.Println(\"empty employee_list:\", employee_list) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" fmt.Println(\"all employee:\", employee_list) fmt.Println(\"3rd employee:\", employee_list[2]) // empty employee_list: [ ] // all employee: [KJ Kay Jay] // 3rd employee: Jay employee_list := []string{\"KJ\", \"Kay\", \"Jay\"} fmt.Println(\"all employee:\", employee_list) // all employee: [KJ Kay Jay] var employee_list []string employee_list = append(employee_list, \"KJ\") employee_list = append(employee_list, \"Kay\") employee_list = append(employee_list, \"Jay\") fmt.Println(\"all employee:\", employee_list) fmt.Println(\"3rd employee:\", employee_list[2]) // all employee: [KJ Kay Jay] // 3rd employee: Jay slice 資料數量 employee_list := make([]string, 3) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" fmt.Println(\"len:\", len(employee_list)) // len: 3 加入 slice 資料 employee_list := make([]string, 3) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" employee_list = append(employee_list, \"Musk\") employee_list = append(employee_list, \"Bill\", \"Jim\") fmt.Println(\"all employee after append:\", employee_list) // all employee after append: [KJ Kay Jay Musk Bill Jim] 複製 slice 變數  複製的 slice 變數是傳值的方式，所以複製變數的異動不會影響先前的 slice 變數\n employee_list := make([]string, 3) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" // 複製 slice 變數 copy_employee_list := make([]string, len(employee_list)) copy(copy_employee_list, employee_list) fmt.Println(\"all employee:\", employee_list) fmt.Println(\"all copy employee:\", copy_employee_list) // all employee: [KJ Kay Jay] // all copy employee: [KJ Kay Jay]  // 變更複製的 slice copy_employee_list[2] = \"Change Name\" fmt.Println(\"all employee after change:\", employee_list) fmt.Println(\"all copy employee after change:\", copy_employee_list) // all employee after change: [KJ Kay Jay] // all copy employee after change: [KJ Kay Change Name] 取得指定 slice 範圍的變數 employee_list := make([]string, 6) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" employee_list[3] = \"Musk\" employee_list[4] = \"Bill\" employee_list[5] = \"Jim\"  slice[\u003c從第幾個元素\u003e:\u003c到第幾個元素(不含此元素)\u003e]\n slice_employee_list := employee_list[2:5] fmt.Println(\"employee_list:\", employee_list) fmt.Println(\"slice_employee_list:\", slice_employee_list) // employee_list: [KJ Kay Jay Musk Bill Jim] // slice_employee_list: [Jay Musk Bill]   slice[:\u003c到第幾個元素(不含此元素)\u003e]\n slice_employee_list := employee_list[:3] fmt.Println(\"employee_list:\", employee_list) fmt.Println(\"slice_employee_list:\", slice_employee_list) // employee_list: [KJ Kay Jay Musk Bill Jim] // slice_employee_list: [KJ Kay Jay]  slice[\u003c從第幾個元素\u003e:]\n slice_employee_list := employee_list[2:] fmt.Println(\"employee_list:\", employee_list) fmt.Println(\"slice_employee_list:\", slice_employee_list) // employee_list: [KJ Kay Jay Musk Bill Jim] // slice_employee_list: [Jay Musk Bill Jim] 參考資料  Go by Example: Slices slice | golang 個人筆記和心得  ","categories":["Golang","教學文件","新手教學","基礎","Slice 變數","進階陣列"],"description":"Golang 基礎: Slice 變數: 進階陣列","excerpt":"Golang 基礎: Slice 變數: 進階陣列","ref":"/basic/data-type/slice/","tags":["Golang","教學文件","新手教學","基礎","Slice 變數","進階陣列"],"title":"Slice 變數: 進階陣列"},{"body":"建立 Map 變數 m := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 fmt.Println(\"map:\", m) // map: map[key_1:7 key_2:13] 取得 Map 鍵值資料 m := make(map[string]int) m[\"key_1\"] = 7 v1 := m[\"key_1\"] fmt.Println(\"v1: \", v1) // v1: 7 Map 資料數量 m := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 fmt.Println(\"len:\", len(m)) // len: 2 刪除 Map 指定鍵值資料 m := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 fmt.Println(\"map:\", m) // map: map[key_1:7 key_2:13]  delete(m, \"key_1\") fmt.Println(\"map:\", m) // map: map[key_2:13] 判斷鍵值是否存在 僅需要判斷資料是否存在，沒有需要使用該數值的話，可以將第一個參數設定為 底線 _，用第二個變數來判斷是否存在\nm := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 _, is_key2_exist := m[\"key_2\"] _, is_key3_exist := m[\"key_3\"] fmt.Println(\"is_key2_exist:\", is_key2_exist) fmt.Println(\"is_key3_exist:\", is_key3_exist) // is_key2_exist: true // is_key3_exist: false 直接指定數值 m := map[string]string{\"name\": `KJ`, \"age\": `18`} fmt.Println(\"developer:\", m) // developer: map[age:18 name:KJ] 參考資料  Go by Example: Maps  ","categories":["Golang","教學文件","新手教學","基礎","Map 變數","key-value 陣列"],"description":"Golang 基礎: Map 變數: key-value 陣列","excerpt":"Golang 基礎: Map 變數: key-value 陣列","ref":"/basic/data-type/map/","tags":["Golang","教學文件","新手教學","基礎","Map 變數","key-value 陣列"],"title":"Map 變數: key-value 陣列"},{"body":"","categories":["Golang","教學文件","新手教學","常見問題","語言特性"],"description":"語言特性","excerpt":"語言特性","ref":"/question/feature/","tags":["Golang","教學文件","新手教學","常見問題","語言特性"],"title":"語言特性"},{"body":"接收不會用到的變數參數 在 golang 如果變數有宣告但沒有用到，在編譯的時候是無法順利編譯執行的\n像在 for range 迴圈我們會去取他的 key 跟 value，但 key 對我們來說可能是沒有要用到的變數，這樣執行會出現 key declared but not used 的訊息\nnums := []int{2, 3, 4} sum := 0 for key, value := range nums { sum += value } fmt.Println(\"sum:\", sum) // key declared but not used 對於沒有用途的變數可以用 底線 _ 取做變數指定，這樣就不會建立了不會用到的變數\nnums := []int{2, 3, 4} sum := 0 for _, value := range nums { sum += value } fmt.Println(\"sum:\", sum) // sum: 9 判斷鍵值是否存在 僅需要判斷資料是否存在，沒有需要使用該數值的話，可以將第一個參數設定為 底線 _，用第二個變數來判斷是否存在\nm := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 _, is_key2_exist := m[\"key_2\"] _, is_key3_exist := m[\"key_3\"] fmt.Println(\"is_key2_exist:\", is_key2_exist) fmt.Println(\"is_key3_exist:\", is_key3_exist) // is_key2_exist: true // is_key3_exist: false 參考資料  variables - What is “_,” (underscore comma) in a Go declaration? - Stack Overflow The blank identifier - Effective Go - The Go Programming Language  ","categories":["Golang","教學文件","新手教學","常見問題","語言特性","底線","underscore comma"],"description":"底線逗號 `_` underscore comma，空白識別字元 blank identifier","excerpt":"底線逗號 `_` underscore comma，空白識別字元 blank identifier","ref":"/question/feature/blank-identifier/","tags":["Golang","教學文件","新手教學","常見問題","語言特性","底線","underscore comma"],"title":"底線逗號 `_` underscore comma"},{"body":"","categories":["Golang","教學文件","新手教學","基礎","迴圈"],"description":"Golang 基礎: 迴圈","excerpt":"Golang 基礎: 迴圈","ref":"/basic/loop/","tags":["Golang","教學文件","新手教學","基礎","迴圈"],"title":"迴圈"},{"body":"參考資料  Go 语言运算符 | 菜鸟教程  ","categories":["Golang","教學文件","新手教學","基礎","運算元","Operators"],"description":"Golang 基礎: 運算元 Operators","excerpt":"Golang 基礎: 運算元 Operators","ref":"/basic/operators/","tags":["Golang","教學文件","新手教學","基礎","運算元","Operators"],"title":"運算元"},{"body":"","categories":["Golang","教學文件","新手教學","常見問題","Debug"],"description":"Debug","excerpt":"Debug","ref":"/question/debug/","tags":["Golang","教學文件","新手教學","常見問題","Debug"],"title":"Debug"},{"body":"在測試除錯時，想要中斷後面的程式，可以使用 os.Exit(0)\n中斷程式沒有錯誤代碼 去中斷整個程式的執行，參數為 0 實則不會列印出錯誤代碼\npackage main import ( \"fmt\" \"os\" ) func main() { fmt.Println(\"Hello World\") // 中斷程式 \tos.Exit(0) // 不會執行 \tfmt.Println(\"Something else...\") } 中斷程式含錯誤代碼 在 os.Exit(1) 帶入參數則可以顯示錯誤代碼\npackage main import ( \"fmt\" \"os\" ) func main() { fmt.Println(\"Exits with status code 1\") // 列印錯誤代碼 \tos.Exit(1) } 參考資料  Exit an Application, With or Without an Error Code · GolangCode Exit with error code in go? - Stack Overflow  ","categories":["Golang","教學文件","新手教學","常見問題","Debug","中斷程式"],"description":"中斷程式","excerpt":"中斷程式","ref":"/question/debug/exit-application/","tags":["Golang","教學文件","新手教學","常見問題","Debug","中斷程式"],"title":"中斷程式"},{"body":"新增連結變數 type Developer struct { name string // 姓名 \tage int // 年齡 \tNextDeveloper *Developer } 使用 new 新增 NewDeveloper := new(Developer) 使用 \u0026 新增並給予預設值 var NewDeveloper *Developer = \u0026Developer{ name: \"KJ\", age: 17, } TestDeveloper := \u0026Developer{ name: \"KJ\", age: 17, } 輪詢鏈結資料 package main import ( \"fmt\" ) type Developer struct { name string // 姓名 \tage int // 年齡 \tNextDeveloper *Developer } func main() { // 第 1 位工程師節點 \tvar FirstDeveloper *Developer = \u0026Developer{ name: \"KJ\", age: 17, } // 第 2 位工程師節點 \tvar SecondDeveloper *Developer = \u0026Developer{ name: \"Kay\", age: 19, } // 第 3 位工程師節點 \tvar ThirdDeveloper Developer ThirdDeveloper.name = `Jay` ThirdDeveloper.age = 23 // 插入「第 2 位工程師節點位址」到「第 1 位工程師節點」的 NextDeveloper 變數中 \tFirstDeveloper.NextDeveloper = SecondDeveloper // 插入「第 3 位工程師節點位址」到「第 2 位工程師節點」的 NextDeveloper 變數中 \tSecondDeveloper.NextDeveloper = \u0026ThirdDeveloper // 建立變數，搜尋節點資訊，並指向「第 1 位工程師節點」 \tSearchDeveloper := FirstDeveloper // 只要搜尋的節點中的資訊不為空，就會列印節點資訊 \tfor SearchDeveloper != nil { // fmt.Println(*SearchDeveloper) \tfmt.Printf(\"Developer: %+v\\n\", SearchDeveloper) //將欲查看的下個節點 指向 已查看完節點的Next字段 \tSearchDeveloper = SearchDeveloper.NextDeveloper } } // Developer: \u0026{name:KJ age:17 NextDeveloper:0xc0000b8020} // Developer: \u0026{name:Kay age:19 NextDeveloper:0xc0000b8040} // Developer: \u0026{name:Jay age:23 NextDeveloper:\u003cnil\u003e} 參考資料  Linked List in Go (Golang) - golangprograms.com Go by Example: Pointers Golang資料結構-day14-鏈表(Linked list) | Taroballz StudyNotes list - The Go Programming Language #21 鏈結串列 Linked-list | Golang魔法使 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 Container 3兄弟-List - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 [Golang] 程式設計教學：泛型 (Generics) 相關的議題 | Michael Chen 的技術文件  ","categories":["Golang","教學文件","新手教學","基礎","Linked list","鏈表"],"description":"Golang 基礎: Linked list 變數: 鏈表","excerpt":"Golang 基礎: Linked list 變數: 鏈表","ref":"/basic/data-type/linked-list/","tags":["Golang","教學文件","新手教學","基礎","Linked list","鏈表"],"title":"Linked list 變數: 鏈表"},{"body":"package main import \"fmt\" func changeNameByValue(name_value string) { name_value = `KJ` } func changeNameByPointer(name_pointer *string) { *name_pointer = `KJ` } func main() { name := `Nobody` fmt.Println(\"initial Name:\", name) // call by value \tchangeNameByValue(name) fmt.Println(\"after changeNameByValue:\", name) // call by reference \tchangeNameByPointer(\u0026name) fmt.Println(\"after changeNameByPointer:\", name) fmt.Println(\"Name pointer:\", \u0026name) } // initial Name: Nobody // after changeNameByValue: Nobody // after changeNameByPointer: KJ // Name pointer: 0xc000010240 參考資料  Go by Example: Pointers Go - Call by reference - Tutorialspoint  ","categories":["Golang","教學文件","新手教學","基礎","Pointer","指標","call by reference","call by value"],"description":"Golang 基礎: Pointer 變數 指標","excerpt":"Golang 基礎: Pointer 變數 指標","ref":"/basic/data-type/pointer/","tags":["Golang","教學文件","新手教學","基礎","Pointer","指標","call by reference","call by value"],"title":"Pointer 變數: 指標"},{"body":"題目 有 Person 及 Address 資料表，Person 不一定會有 Address\n在不管有沒有 Address 的條件撈取出 FirstName,LastName, City, State 欄位資料\nPerson 資料表\n   Column Name Type     PersonId int   FirstName varchar   LastName varchar    Address 資料表\n   Column Name Type     AddressId int   PersonId int   City varchar   State varchar    答案 # Write your MySQL query statement below SELECT `FirstName`, `LastName`, `City`, `State` FROM `Person` LEFT JOIN `Address` ON `Person`.`PersonId` = `Address`.`PersonId` 參考資料  Combine Two Tables - LeetCode  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0175 - Combine Two Table"],"description":"Golang Leetcode 問題: 0175 - Combine Two Table","excerpt":"Golang Leetcode 問題: 0175 - Combine Two Table","ref":"/leetcode/question/0101-0200/0175-combine-two-table/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0175 - Combine Two Table"],"title":"0175 - Combine Two Table"},{"body":"題目 找出 Employee 資料表第二高薪的薪水\n 若沒有第二高薪水的話則回傳 null 若第一高有兩個人，薪水一樣高，但沒其他人了，則第二高為 null  Employee 資料表\n   Id Salary     1 100   2 200   3 300   4 100    # Write your MySQL query statement below SELECT( SELECT DISTINCT `Salary` FROM `Employee` ORDER BY `Salary` DESC LIMIT 1 OFFSET 1 ) as `SecondHighestSalary` ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0176 - Second Highest Salary"],"description":"Golang Leetcode 問題: 0176 - Second Highest Salary","excerpt":"Golang Leetcode 問題: 0176 - Second Highest Salary","ref":"/leetcode/question/0101-0200/0176-second-highest-salary/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0176 - Second Highest Salary"],"title":"0176 - Second Highest Salary"},{"body":"","categories":["Golang","教學文件","新手教學","Leetcode","問題"],"description":"Golang Leetcode 問題","excerpt":"Golang Leetcode 問題","ref":"/leetcode/question/","tags":["Golang","教學文件","新手教學","Leetcode","問題"],"title":"問題"},{"body":"","categories":["Golang","教學文件","新手教學"],"description":"","excerpt":"","ref":"/docs/","tags":["Golang","教學文件","新手教學"],"title":"教學文件"},{"body":"參考資料  GolangCode - A Library of Go Snippets  ","categories":["Golang","教學文件","新手教學","常見問題"],"description":"Golang 常見問題","excerpt":"Golang 常見問題","ref":"/question/","tags":["Golang","教學文件","新手教學","常見問題"],"title":"Golang 常見問題"},{"body":"官方  A Tour of Go  教學網站  Go 語言教學 | 線上程式語言教學練習 GoLang入門基礎: - HackMD GoLang進階語法: - HackMD GoLang 應用範例: - HackMD Learn Go with tests - learn-go-with-tests Introduction - 使用 Golang 打造 Web 應用程式  GitHub - doggy8088/build-web-application-with-golang-zhtw: 使用 Golang 打造 Web 應用程式 (正體中文版)   Go Tutorial - Tutorialspoint  範例  Go by Example 序 | LeetCode Cookbook  GitHub - halfrost/LeetCode-Go: ✅ Solutions to LeetCode by Go, 100% test coverage, runtime beats 100% / LeetCode 题解    文章  [Golang] 程式設計教學 | Michael Chen 的技術文件  Go 語言筆記(0) — 學這能幹嘛？. 「即將啟程的旅人啊，汝為何而Go?」 | by Jyue Chen | 整個程式都是我的咖啡館 | Medium   從無到有，使用 Go 開發應用程式 :: 2018 iT 邦幫忙鐵人賽  影片  Learn Go Programming - Golang Tutorial for Beginners - YouTube  ","categories":["Golang","教學文件","新手教學","資源"],"description":"Golang 資源","excerpt":"Golang 資源","ref":"/docs/resource/","tags":["Golang","教學文件","新手教學","資源"],"title":"資源"},{"body":"","categories":["Golang","教學文件","新手教學","Leetcode"],"description":"Golang Leetcode","excerpt":"Golang Leetcode","ref":"/leetcode/","tags":["Golang","教學文件","新手教學","Leetcode"],"title":"Leetcode"},{"body":"  #td-cover-block-0 { background-image: url(/hugo-background-1_hu348189a7f185b762e60e6aa110cecbb0_75733_960x540_fill_catmullrom_bottom_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/hugo-background-1_hu348189a7f185b762e60e6aa110cecbb0_75733_1920x1080_fill_catmullrom_bottom_2.png); } }  Golang for newbie Golang 菜雞踩雷學習筆記        記錄學習 Golang 遇到各種不同的系統狀況處理紀錄\n   ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: url(/hugo-background-1_hu348189a7f185b762e60e6aa110cecbb0_75733_960x540_fill_catmullrom_bottom_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: …","ref":"/","tags":"","title":"Golang for newbie"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/golang/","tags":"","title":"Golang"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/golang/","tags":"","title":"Golang"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/operators/","tags":"","title":"Operators"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/operators/","tags":"","title":"Operators"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E4%BD%8D%E5%85%83-bits-%E9%81%8B%E7%AE%97/","tags":"","title":"位元 bits 運算"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E4%BD%8D%E5%85%83-bits-%E9%81%8B%E7%AE%97/","tags":"","title":"位元 bits 運算"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%9F%BA%E7%A4%8E/","tags":"","title":"基礎"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%9F%BA%E7%A4%8E/","tags":"","title":"基礎"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%95%99%E5%AD%B8%E6%96%87%E4%BB%B6/","tags":"","title":"教學文件"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%95%99%E5%AD%B8%E6%96%87%E4%BB%B6/","tags":"","title":"教學文件"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8/","tags":"","title":"新手教學"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8/","tags":"","title":"新手教學"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%81%8B%E7%AE%97%E5%85%83/","tags":"","title":"運算元"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%81%8B%E7%AE%97%E5%85%83/","tags":"","title":"運算元"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0003-longest-substring-without-repeating-characters/","tags":"","title":"0003 - Longest Substring Without Repeating Characters"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0003-longest-substring-without-repeating-characters/","tags":"","title":"0003 - Longest Substring Without Repeating Characters"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0004-median-of-two-sorted-arrays/","tags":"","title":"0004 - Median of Two Sorted Arrays"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0004-median-of-two-sorted-arrays/","tags":"","title":"0004 - Median of Two Sorted Arrays"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/leetcode/","tags":"","title":"Leetcode"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/leetcode/","tags":"","title":"Leetcode"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%95%8F%E9%A1%8C/","tags":"","title":"問題"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%95%8F%E9%A1%8C/","tags":"","title":"問題"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/call-by-reference/","tags":"","title":"call by reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/call-by-reference/","tags":"","title":"call by reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/call-by-value/","tags":"","title":"call by value"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/call-by-value/","tags":"","title":"call by value"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/pointer/","tags":"","title":"Pointer"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/pointer/","tags":"","title":"Pointer"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%8C%87%E6%A8%99/","tags":"","title":"指標"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%8C%87%E6%A8%99/","tags":"","title":"指標"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0002-add-two-number/","tags":"","title":"0002 - Add Two Number"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0002-add-two-number/","tags":"","title":"0002 - Add Two Number"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/linked-list/","tags":"","title":"Linked list"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/linked-list/","tags":"","title":"Linked list"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%8F%88%E8%A1%A8/","tags":"","title":"鏈表"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%8F%88%E8%A1%A8/","tags":"","title":"鏈表"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0175-combine-two-table/","tags":"","title":"0175 - Combine Two Table"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0175-combine-two-table/","tags":"","title":"0175 - Combine Two Table"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0176-second-highest-salary/","tags":"","title":"0176 - Second Highest Salary"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0176-second-highest-salary/","tags":"","title":"0176 - Second Highest Salary"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0001-two-sum/","tags":"","title":"0001 - Two Sum"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0001-two-sum/","tags":"","title":"0001 - Two Sum"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/for-range-%E8%BF%B4%E5%9C%88/","tags":"","title":"for range 迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/for-range-%E8%BF%B4%E5%9C%88/","tags":"","title":"for range 迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/key-value-%E9%99%A3%E5%88%97/","tags":"","title":"key-value 陣列"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/key-value-%E9%99%A3%E5%88%97/","tags":"","title":"key-value 陣列"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/map-%E8%AE%8A%E6%95%B8/","tags":"","title":"Map 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/map-%E8%AE%8A%E6%95%B8/","tags":"","title":"Map 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/slice-%E8%AE%8A%E6%95%B8/","tags":"","title":"Slice 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/slice-%E8%AE%8A%E6%95%B8/","tags":"","title":"Slice 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/underscore-comma/","tags":"","title":"underscore comma"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/underscore-comma/","tags":"","title":"underscore comma"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C/","tags":"","title":"常見問題"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C/","tags":"","title":"常見問題"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%BA%95%E7%B7%9A/","tags":"","title":"底線"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%BA%95%E7%B7%9A/","tags":"","title":"底線"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E8%AA%9E%E8%A8%80%E7%89%B9%E6%80%A7/","tags":"","title":"語言特性"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%AA%9E%E8%A8%80%E7%89%B9%E6%80%A7/","tags":"","title":"語言特性"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%80%B2%E9%9A%8E%E9%99%A3%E5%88%97/","tags":"","title":"進階陣列"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%80%B2%E9%9A%8E%E9%99%A3%E5%88%97/","tags":"","title":"進階陣列"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/for-%E8%BF%B4%E5%9C%88/","tags":"","title":"for 迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/for-%E8%BF%B4%E5%9C%88/","tags":"","title":"for 迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E4%B8%80%E8%88%AC%E8%AE%8A%E6%95%B8/","tags":"","title":"一般變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E4%B8%80%E8%88%AC%E8%AE%8A%E6%95%B8/","tags":"","title":"一般變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%88%97%E5%8D%B0/","tags":"","title":"列印"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%88%97%E5%8D%B0/","tags":"","title":"列印"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%88%97%E5%8D%B0%E6%A0%BC%E5%BC%8F/","tags":"","title":"列印格式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%88%97%E5%8D%B0%E6%A0%BC%E5%BC%8F/","tags":"","title":"列印格式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E8%AE%8A%E6%95%B8%E9%A1%9E%E5%9E%8B/","tags":"","title":"變數類型"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%AE%8A%E6%95%B8%E9%A1%9E%E5%9E%8B/","tags":"","title":"變數類型"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E8%BF%B4%E5%9C%88/","tags":"","title":"迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%BF%B4%E5%9C%88/","tags":"","title":"迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%99%A3%E5%88%97%E8%AE%8A%E6%95%B8/","tags":"","title":"陣列變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%99%A3%E5%88%97%E8%AE%8A%E6%95%B8/","tags":"","title":"陣列變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/debug/","tags":"","title":"Debug"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/debug/","tags":"","title":"Debug"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E4%B8%AD%E6%96%B7%E7%A8%8B%E5%BC%8F/","tags":"","title":"中斷程式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E4%B8%AD%E6%96%B7%E7%A8%8B%E5%BC%8F/","tags":"","title":"中斷程式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E8%B3%87%E6%BA%90/","tags":"","title":"資源"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%B3%87%E6%BA%90/","tags":"","title":"資源"}]