



















































































































































[{"body":"Go 版本 $ go version go version go1.18 darwin/amd64 ","categories":["Golang","教學文件","新手教學","基礎","環境"],"description":"Golang 基礎: 環境","excerpt":"Golang 基礎: 環境","ref":"/basic/environment/","tags":["Golang","教學文件","新手教學","基礎","環境"],"title":"環境"},{"body":"題目 傳入 數字列表 及 最後答案加總數值，回傳 最後答案加總數值 是 數字列表 的第幾個跟第幾個數字的加總\n答案 func twoSum(nums_list []int, final_sum_value int) []int { // 數字反向對應表 \tnum_reverse_mapping := make(map[int]int) for key, value := range nums_list { // 判斷是否其他數值存在 \tif other_value_key, is_other_value_exist := num_reverse_mapping[final_sum_value-value]; is_other_value_exist { // 回傳其他數值鍵值 + 目前數值鍵值 \treturn []int{other_value_key, key} } // 設定數值反向對應表：數值 =\u003e 鍵值 \tnum_reverse_mapping[value] = key } return nil } 完整程式碼 package main import ( \"fmt\" ) type question struct { // 參數 \tparameter // 答案 \tanswer } // 參數 type parameter struct { nums_list []int final_sum_value int } // 答案 type answer struct { one []int } func main() { question_list := []question{ { parameter{[]int{3, 2, 4}, 6}, answer{[]int{1, 2}}, }, { parameter{[]int{3, 2, 4}, 5}, answer{[]int{0, 1}}, }, { parameter{[]int{0, 8, 7, 3, 3, 4, 2}, 11}, answer{[]int{1, 3}}, }, { parameter{[]int{0, 1}, 1}, answer{[]int{0, 1}}, }, { parameter{[]int{0, 3}, 5}, answer{[]int{}}, }, } fmt.Printf(\"------------------------Leetcode Problem 1------------------------\\n\") for _, question := range question_list { // _, p := question.answer, question.parameter \tparam := question.parameter fmt.Printf(\"【input】:%v 【output】:%v\\n\", param, twoSum(param.nums_list, param.final_sum_value)) } } func twoSum(nums_list []int, final_sum_value int) []int { // 數字反向對應表 \tnum_reverse_mapping := make(map[int]int) for key, value := range nums_list { // 判斷是否其他數值存在 \tif other_value_key, is_other_value_exist := num_reverse_mapping[final_sum_value-value]; is_other_value_exist { // 回傳其他數值鍵值 + 目前數值鍵值 \treturn []int{other_value_key, key} } // 設定數值反向對應表：數值 =\u003e 鍵值 \tnum_reverse_mapping[value] = key } return nil } 參考資料  Two Sum - LeetCode 0001. Two Sum | LeetCode Cookbook  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0001 - Two Sum"],"description":"Golang Leetcode 問題: 0001 - Two Sum","excerpt":"Golang Leetcode 問題: 0001 - Two Sum","ref":"/leetcode/question/0001-0100/0001-two-sum/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0001 - Two Sum"],"title":"0001 - Two Sum"},{"body":"題目  You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n  You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n 傳入 數字列表 及 最後答案加總數值，回傳 最後答案加總數值 是 數字列表 的第幾個跟第幾個數字的加總\n答案 func addTwoNumbers(FirstNumberListNode *ListNode, SecondNumberListNode *ListNode) *ListNode { AnswerListNode := \u0026ListNode{Val: 0} // 建立答案節點，預設個位數是 0 \tCurrentAnswerListNode := AnswerListNode // 目前答案節點 \tnumber_1 := 0 // 第 1 個加總數值 \tnumber_2 := 0 // 第 2 個加總數值 \tcarry_number := 0 // 加總後的進位數值 \tnumber_sum := 0 // 加總數值  // 若「第 1 數字節點」或「第 2 數字節點」有資料不為 nil 時，或沒有任何進位數字時 \tfor FirstNumberListNode != nil || SecondNumberListNode != nil || carry_number != 0 { // 判斷「第 1 數字節點」 \tif FirstNumberListNode == nil { // 若「第 1 數字節點」為 nil，表示沒有數字可以做加總了，設定可加總數字為 0 \tnumber_1 = 0 } else { // 若「第 1 數字節點」有值，將節點數值設定為此次第 1 個加總數值 \tnumber_1 = FirstNumberListNode.Val FirstNumberListNode = FirstNumberListNode.Next } // 判斷「第 2 數字節點」 \tif SecondNumberListNode == nil { // 若「第 2 數字節點」為 nil，表示沒有數字可以做加總了，設定可加總數字為 0 \tnumber_2 = 0 } else { // 若「第 1 數字節點」有值，將節點數值設定為此次第 2 個加總數值 \tnumber_2 = SecondNumberListNode.Val SecondNumberListNode = SecondNumberListNode.Next } // 加總數值 \tnumber_sum = (number_1 + number_2 + carry_number) // 設定餘數為目前答案節點數值 \tCurrentAnswerListNode.Next = \u0026ListNode{Val: number_sum % 10} // 設定答案節點的下一節點為目前節點，繼續往後做加總 \tCurrentAnswerListNode = CurrentAnswerListNode.Next // 取得加總後的進位數值，繼續往後做加總 \tcarry_number = number_sum / 10 } return AnswerListNode.Next } 完整程式碼 package main import ( \"fmt\" ) // ListNode define type ListNode struct { Val int Next *ListNode } // 問題 type question struct { parameter answer } // para 是参数 // one 代表第一个参数 type parameter struct { one []int another []int } // ans 是答案 // one 代表第一个答案 type answer struct { one []int } func main() { // 問題清單 \tquestion_list := []question{ { parameter{[]int{}, []int{}}, answer{[]int{}}, }, { parameter{[]int{1}, []int{1}}, answer{[]int{2}}, }, { parameter{[]int{1, 2, 3, 4}, []int{1, 2, 3, 4}}, answer{[]int{2, 4, 6, 8}}, }, { parameter{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}}, answer{[]int{2, 4, 6, 8, 0, 1}}, }, { parameter{[]int{1}, []int{9, 9, 9, 9, 9}}, answer{[]int{0, 0, 0, 0, 0, 1}}, }, { parameter{[]int{9, 9, 9, 9, 9}, []int{1}}, answer{[]int{0, 0, 0, 0, 0, 1}}, }, { parameter{[]int{2, 4, 3}, []int{5, 6, 4}}, answer{[]int{7, 0, 8}}, }, { parameter{[]int{1, 8, 3}, []int{7, 1}}, answer{[]int{8, 9, 3}}, }, } fmt.Printf(\"------------------------Leetcode Problem 2------------------------\\n\") for _, question := range question_list { param := question.parameter fmt.Printf(\"【input】:%v 【output】:%v\\n\", param, List2Ints(addTwoNumbers(Ints2List(param.one), Ints2List(param.another)))) } fmt.Printf(\"\\n\\n\\n\") } // 連結數字相加 func addTwoNumbers(FirstNumberListNode *ListNode, SecondNumberListNode *ListNode) *ListNode { AnswerListNode := \u0026ListNode{Val: 0} // 建立答案節點，預設個位數是 0 \tCurrentAnswerListNode := AnswerListNode // 目前答案節點 \tnumber_1 := 0 // 第 1 個加總數值 \tnumber_2 := 0 // 第 2 個加總數值 \tcarry_number := 0 // 加總後的進位數值 \tnumber_sum := 0 // 加總數值  // 若「第 1 數字節點」或「第 2 數字節點」有資料不為 nil 時，或沒有任何進位數字時 \tfor FirstNumberListNode != nil || SecondNumberListNode != nil || carry_number != 0 { // 判斷「第 1 數字節點」 \tif FirstNumberListNode == nil { // 若「第 1 數字節點」為 nil，表示沒有數字可以做加總了，設定可加總數字為 0 \tnumber_1 = 0 } else { // 若「第 1 數字節點」有值，將節點數值設定為此次第 1 個加總數值 \tnumber_1 = FirstNumberListNode.Val FirstNumberListNode = FirstNumberListNode.Next } // 判斷「第 2 數字節點」 \tif SecondNumberListNode == nil { // 若「第 2 數字節點」為 nil，表示沒有數字可以做加總了，設定可加總數字為 0 \tnumber_2 = 0 } else { // 若「第 1 數字節點」有值，將節點數值設定為此次第 2 個加總數值 \tnumber_2 = SecondNumberListNode.Val SecondNumberListNode = SecondNumberListNode.Next } // 加總數值 \tnumber_sum = (number_1 + number_2 + carry_number) // 設定餘數為目前答案節點數值 \tCurrentAnswerListNode.Next = \u0026ListNode{Val: number_sum % 10} // 設定答案節點的下一節點為目前節點，繼續往後做加總 \tCurrentAnswerListNode = CurrentAnswerListNode.Next // 取得加總後的進位數值，繼續往後做加總 \tcarry_number = number_sum / 10 } return AnswerListNode.Next } // 鏈結清單轉換成整數陣列 func List2Ints(HeadListNode *ListNode) []int { // 鏈結深度限制，鏈結深度超過限制會出錯 \tlink_list_depth_limit := 100 current_link_list_depth := 0 res := []int{} for HeadListNode != nil { // 若有連結資料 \tcurrent_link_list_depth++ if current_link_list_depth \u003e link_list_depth_limit { msg := fmt.Sprintf(\"鏈結深度超過%d，可能出现環狀鏈結。檢查錯誤，或者調整 List2Ints 函式中 link_list_depth_limit 的限制。\", link_list_depth_limit) panic(msg) } res = append(res, HeadListNode.Val) HeadListNode = HeadListNode.Next } return res } // Ints2List convert []int to List // 整數陣列轉換成鏈結清單 func Ints2List(nums_list []int) *ListNode { if len(nums_list) == 0 { return nil } // 初始化鏈結節點 \tHeadListNode := \u0026ListNode{} // 設定目前鏈結節點 \tCurrentListNode := HeadListNode for _, number := range nums_list { // 設定鏈結節點的下一節點 \tCurrentListNode.Next = \u0026ListNode{Val: number} // 將下一節點設為目前節點 \tCurrentListNode = CurrentListNode.Next } return HeadListNode.Next } 參考資料  Two Sum - LeetCode 0001. Two Sum | LeetCode Cookbook  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0002 - Add Two Number"],"description":"Golang Leetcode 問題: 0002 - Add Two Number","excerpt":"Golang Leetcode 問題: 0002 - Add Two Number","ref":"/leetcode/question/0001-0100/0002-add-two-number/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0002 - Add Two Number"],"title":"0002 - Add Two Number"},{"body":"題目  Given a string s, find the length of the longest substring without repeating characters.\n 傳入 字串變數 ，找出 最長的子字串字元 長度\n答案 1. 解法1 使用 bit func lengthOfLongestSubstring1(check_text string) int { // 被檢查的文字長度 \tcheck_text_length := len(check_text) if check_text_length == 0 { // 驗證字串長度為 0 不檢查 \treturn 0 } // 文字 ASCII 檢查設定，預設都沒有找到此文字 false \tvar text_ascii_bit_set [256]bool // 右方指標字元 ASCII Code \tvar right_character_ascii_code uint8 // 左方指標字元 ASCII Code \tvar left_character_ascii_code uint8 // 左方字元索引 \tleft_character_index := 0 // 右方字元索引 \tright_character_index := 0 // 檢查文字最大不重複字串長度 \tcheck_text_longest_string_length := 0 // 目前字串長度 \tcurrent_text_string_length := 0 for left_character_index \u003c check_text_length { // 左側字元索引小於檢查字串長度，還沒有全部檢查完，繼續檢查  // 右方指標字元 ASCII Code \tright_character_ascii_code = check_text[right_character_index] // 左方指標字元 ASCII Code \tleft_character_ascii_code = check_text[left_character_index] if text_ascii_bit_set[right_character_ascii_code] { // 若右方文字已經有出現過，表示從左方索引到右方索引中間已經有出現過該文字 \t// 左方文字設定為未出現過 false \ttext_ascii_bit_set[left_character_ascii_code] = false // 左方往右推進 1 個字元，繼續檢查搜尋 \tleft_character_index++ } else { // 右方文字沒有出現過，設定右方文字為已出現過 true \ttext_ascii_bit_set[right_character_ascii_code] = true // 右方指標往前搜尋 \tright_character_index++ } // 設定目前字串長度 \tcurrent_text_string_length = right_character_index - left_character_index if check_text_longest_string_length \u003c current_text_string_length { // 若右方指標在左方指標前面，且長度大於目前檢查文字的最大長度，將目前長度設定為最大長度 \tcheck_text_longest_string_length = current_text_string_length } if left_character_index+check_text_longest_string_length \u003e= check_text_length || right_character_index \u003e= check_text_length { // 1. 左方字元索引 + 目前檢查文字的最大長度 \u003e 文字最大長度：再往右找也找不到更長的文字了 \t// 2. 右方字元索引 \u003e= 被檢查的文字長度 : 已經檢查到最後一個字元了 \t// 跳出檢查 \tbreak } } return check_text_longest_string_length } 2. 解法2 使用 sliding window func lengthOfLongestSubstring(check_text string) int { // 被檢查的文字長度 \tcheck_text_length := len(check_text) if check_text_length == 0 { // 驗證字串長度為 0 不檢查 \treturn 0 } // 建立長度 256 的整數陣列 \tvar text_ascii_int_flag [256]int // 左方字元索引 \tleft_character_index := 0 // 右方字元索引 \tright_character_index := 0 // 檢查文字最大不重複字串長度 \tcheck_text_longest_string_length := 0 // 右方指標字元 ASCII Code \tvar right_character_ascii_code uint8 // 左方指標字元 ASCII Code \tvar left_character_ascii_code uint8 // 目前字串長度 \tcurrent_text_string_length := 0 for left_character_index \u003c check_text_length { // 若左側指標小於字串長度，繼續檢查 \tif right_character_index \u003e= check_text_length { // 若右側指標大於字串長度，表示已經檢查到最後的字串了，不需要再檢查 \tbreak } // 右方指標字元 ASCII Code \tright_character_ascii_code = check_text[right_character_index] if text_ascii_int_flag[right_character_ascii_code] == 0 { // 「右側指標 +1 小於字串長度，表示字串還沒全部檢查完」且「此文字未出現過」 \t// 標記右方文字出現過 \ttext_ascii_int_flag[right_character_ascii_code] = 1 // 繼續往右檢查 \tright_character_index++ } else { // 左方指標字元 ASCII Code \tleft_character_ascii_code = check_text[left_character_index] // 標記左方文字沒出現過 \ttext_ascii_int_flag[left_character_ascii_code] = 0 // 將左方指標往前移動 \tleft_character_index++ } // 設定目前字串長度 \tcurrent_text_string_length = right_character_index - left_character_index if check_text_longest_string_length \u003c current_text_string_length { // 若右方指標在左方指標前面，且長度大於目前檢查文字的最大長度，將目前長度設定為最大長度 \tcheck_text_longest_string_length = current_text_string_length } } return check_text_longest_string_length } 完整程式碼 package main import ( \"fmt\" ) type QuestionList struct { Parameter Answer } // Parameter 是参数 // check_text 代表檢查的字串 type Parameter struct { check_text string } // Answer 是答案 // one 代表第一个答案 type Answer struct { one int } func main() { question_list := []QuestionList{ { Parameter{\"abcabcbb\"}, Answer{3}, }, { Parameter{\"bbbbb\"}, Answer{1}, }, { Parameter{\"pwwkew\"}, Answer{3}, }, { Parameter{\"\"}, Answer{0}, }, } fmt.Printf(\"------------------------Leetcode Problem 3------------------------\\n\") for _, question := range question_list { // 問題參數 \tParam := question.Parameter fmt.Printf(\"solution 1【input】:%v 【output】:%v\\n\", Param, lengthOfLongestSubstring1(Param.check_text)) fmt.Printf(\"solution 2【input】:%v 【output】:%v\\n\", Param, lengthOfLongestSubstring2(Param.check_text)) } fmt.Printf(\"\\n\\n\\n\") } // 解法1 使用 bit func lengthOfLongestSubstring1(check_text string) int { // 被檢查的文字長度 \tcheck_text_length := len(check_text) if check_text_length == 0 { // 驗證字串長度為 0 不檢查 \treturn 0 } // 文字 ASCII 檢查設定，預設都沒有找到此文字 false \tvar text_ascii_bit_set [256]bool // 右方指標字元 ASCII Code \tvar right_character_ascii_code uint8 // 左方指標字元 ASCII Code \tvar left_character_ascii_code uint8 // 左方字元索引 \tleft_character_index := 0 // 右方字元索引 \tright_character_index := 0 // 檢查文字最大不重複字串長度 \tcheck_text_longest_string_length := 0 // 目前字串長度 \tcurrent_text_string_length := 0 for left_character_index \u003c check_text_length { // 左側字元索引小於檢查字串長度，還沒有全部檢查完，繼續檢查  // 右方指標字元 ASCII Code \tright_character_ascii_code = check_text[right_character_index] // 左方指標字元 ASCII Code \tleft_character_ascii_code = check_text[left_character_index] if text_ascii_bit_set[right_character_ascii_code] { // 若右方文字已經有出現過，表示從左方索引到右方索引中間已經有出現過該文字 \t// 左方文字設定為未出現過 false \ttext_ascii_bit_set[left_character_ascii_code] = false // 左方往右推進 1 個字元，繼續檢查搜尋 \tleft_character_index++ } else { // 右方文字沒有出現過，設定右方文字為已出現過 true \ttext_ascii_bit_set[right_character_ascii_code] = true // 右方指標往前搜尋 \tright_character_index++ } // 設定目前字串長度 \tcurrent_text_string_length = right_character_index - left_character_index if check_text_longest_string_length \u003c current_text_string_length { // 若右方指標在左方指標前面，且長度大於目前檢查文字的最大長度，將目前長度設定為最大長度 \tcheck_text_longest_string_length = current_text_string_length } if left_character_index+check_text_longest_string_length \u003e= check_text_length || right_character_index \u003e= check_text_length { // 1. 左方字元索引 + 目前檢查文字的最大長度 \u003e 文字最大長度：再往右找也找不到更長的文字了 \t// 2. 右方字元索引 \u003e= 被檢查的文字長度 : 已經檢查到最後一個字元了 \t// 跳出檢查 \tbreak } } return check_text_longest_string_length } // 解法2 Sliding Window func lengthOfLongestSubstring2(check_text string) int { // 被檢查的文字長度 \tcheck_text_length := len(check_text) if check_text_length == 0 { // 驗證字串長度為 0 不檢查 \treturn 0 } // 建立長度 256 的整數陣列 \tvar text_ascii_int_flag [256]int // 左方字元索引 \tleft_character_index := 0 // 右方字元索引 \tright_character_index := 0 // 檢查文字最大不重複字串長度 \tcheck_text_longest_string_length := 0 // 右方指標字元 ASCII Code \tvar right_character_ascii_code uint8 // 左方指標字元 ASCII Code \tvar left_character_ascii_code uint8 // 目前字串長度 \tcurrent_text_string_length := 0 for left_character_index \u003c check_text_length { // 若左側指標小於字串長度，繼續檢查 \tif right_character_index \u003e= check_text_length { // 若右側指標大於字串長度，表示已經檢查到最後的字串了，不需要再檢查 \tbreak } // 右方指標字元 ASCII Code \tright_character_ascii_code = check_text[right_character_index] if text_ascii_int_flag[right_character_ascii_code] == 0 { // 「右側指標 +1 小於字串長度，表示字串還沒全部檢查完」且「此文字未出現過」 \t// 標記右方文字出現過 \ttext_ascii_int_flag[right_character_ascii_code] = 1 // 繼續往右檢查 \tright_character_index++ } else { // 左方指標字元 ASCII Code \tleft_character_ascii_code = check_text[left_character_index] // 標記左方文字沒出現過 \ttext_ascii_int_flag[left_character_ascii_code] = 0 // 將左方指標往前移動 \tleft_character_index++ } // 設定目前字串長度 \tcurrent_text_string_length = right_character_index - left_character_index if check_text_longest_string_length \u003c current_text_string_length { // 若右方指標在左方指標前面，且長度大於目前檢查文字的最大長度，將目前長度設定為最大長度 \tcheck_text_longest_string_length = current_text_string_length } } return check_text_longest_string_length } 參考資料  Longest Substring Without Repeating Characters - LeetCode 0003. Longest Substring Without Repeating Characters | LeetCode Cookbook  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0003 - Longest Substring Without Repeating Characters"],"description":"Golang Leetcode 問題: 0003 - Longest Substring Without Repeating Characters","excerpt":"Golang Leetcode 問題: 0003 - Longest Substring Without Repeating Characters","ref":"/leetcode/question/0001-0100/0003-longest-substring-without-repeating-characters/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0003 - Longest Substring Without Repeating Characters"],"title":"0003 - Longest Substring Without Repeating Characters"},{"body":"題目  Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n  The overall run time complexity should be O(log (m+n)).\n 傳入 2 個已排序數字陣列，回傳兩個排序陣列的中位數，複雜度必須為 O(log (m+n)).\n演算法原理 Binary Search : Median of two sorted arrays of different sizes   答案 func findMedianSortedArrays(nums_list_1 []int, nums_list_2 []int) float64 { // 假设 nums1 的长度小  if len(nums_list_1) \u003e len(nums_list_2) { // 若數字清單 1 長度大於數字清單 2，將清單較短的數字清單 2 優先傳入第一個參數  return findMedianSortedArrays(nums_list_2, nums_list_1) } // 「數字清單 1」左方數字索引  num1_left_num_index := 0 // 「數字清單 1」右方數字索引  num1_right_nums_index := len(nums_list_1) // 所有數字中位數可能位置，全部長度+1，bit 往右位移除 2  all_nums_list_divide_position := (len(nums_list_1) + len(nums_list_2) + 1) \u003e\u003e 1 // 「數字清單 1」中位數位置  nums1_median_index := 0 // 「數字清單 2」中位數位置  nums2_median_index := 0 // === 中位數區塊劃分 ===  for num1_left_num_index \u003c= num1_right_nums_index { // 「當左方數字索引」比「右方數字索引」還要小，表示搜尋的數字還沒交叉重複到  // 數字清單 1 中位數位置 = 目前左方最小數字位置 + 右方剩餘數字取中位數 bit 往右位移(除 2)  // 中位數分界點，左側是 median_index -1，右側是 median_index，  // nums1: ……………… nums1[nums1_median_index-1] | nums1[nums1_median_index] ……………………  // nums2: ……………… nums2[nums2_median_index-1] | nums2[nums2_median_index] ……………………  nums1_median_index = num1_left_num_index + (num1_right_nums_index-num1_left_num_index)\u003e\u003e1 // 數字清單 2 中位數位置 = 所有數字中位數可能位置 - 數字清單 1 中位數位置  nums2_median_index = all_nums_list_divide_position - nums1_median_index if nums1_median_index \u003e 0 \u0026\u0026 nums_list_1[nums1_median_index-1] \u003e nums_list_2[nums2_median_index] { // nums1 中的分界线划多了，要向左边移动  // 「數字清單 1」中位數位置不是第一個數字  // 「數字清單 1」中位數左側數字比「數字清單 2」右側中位數還大（排序過的數字左側應比右側小）  // 表示整個數字列表的中位數在「數字清單 1」目前中位數之前  // 「數字清單 1」右方數字索引往左側移動，找「數字清單 1」中位數前面小一點的數字  num1_right_nums_index = nums1_median_index - 1 } else if nums1_median_index != len(nums_list_1) \u0026\u0026 nums_list_1[nums1_median_index] \u003c nums_list_2[nums2_median_index-1] { // nums1 中的分界线划少了，要向右边移动  // 「數字清單 1」中位數位置不是最後一個數字  // 「數字清單 1」中位數右側數字比「數字清單 2」左側中位數還小（排序過的數字右側應比左側大）  // 「數字清單 1」中位數位置數字 比 「數字清單 2」中位數位位置的前一個數字還小  // 「數字清單 1」左方數字索引往右側移動，找「數字清單 1」中位數後面大一點的數字  num1_left_num_index = nums1_median_index + 1 } else { // 無法再劃分左右側中位數位置  break } } // === 找出中位數 ===  // 中位數  var median_num float64 = 0.0 // 左側中位數  median_num_left := 0 // 右側中位數  median_num_right := 0 if nums1_median_index == 0 { // 「數字清單 1」中位數位置為第一個數字  // 中位數左側數字 = 「數字清單 2」 左側第一個數字」  median_num_left = nums_list_2[nums2_median_index-1] } else if nums2_median_index == 0 { // 「數字清單 2」中位數位置為第一個數字  // 中位數左側數字 = 「數字清單 1」 左側第一個數字」  median_num_left = nums_list_1[nums1_median_index-1] } else { // 中位數左側數字 = 「數字清單 1 左側位置第一個數字」與「數字清單 2 左側位置第一個數字」取最大的數字  // 左側的數字比右側小，所以要找比較大的數字才會接近右側數字  median_num_left = max(nums_list_1[nums1_median_index-1], nums_list_2[nums2_median_index-1]) } // 判斷數字數量是奇數還是偶數  if (len(nums_list_1)+len(nums_list_2))\u00261 == 1 { // 若數字總數量為奇數，直接回傳中位數數字  median_num = float64(median_num_left) return median_num } if nums1_median_index == len(nums_list_1) { // 「數字清單 1」中位數位置在不在清單中，索引超出清單長度（索引從 0 開始算）  // 中位數右側數字 = 「數字清單 2」中位數右側第一個數字  median_num_right = nums_list_2[nums2_median_index] } else if nums2_median_index == len(nums_list_2) { // 「數字清單 2」中位數位置在不在清單中，索引超出清單長度（索引從 0 開始算）  // 中位數右側數字 = 「數字清單 1」中位數右側第一個數字  median_num_right = nums_list_1[nums1_median_index] fmt.Println(\"\u003cmedian_num_right (2)\u003e: num1_medium =\u003e nums_list_1[nums1_median_index]\") } else { // 中位數右側數字 = 「數字清單 1 右側第一個數字」與「數字清單 2 右側第一個數字」取最小的數字  // 右側的數字比左側大，所以要找比較小的數字才會接近左側數字  median_num_right = min(nums_list_1[nums1_median_index], nums_list_2[nums2_median_index]) } median_num = float64(median_num_left+median_num_right) / 2 return median_num } func max(a int, b int) int { if a \u003e b { return a } return b } func min(a int, b int) int { if a \u003e b { return b } return a } 完整程式碼 package main import ( \"fmt\" ) type QuestionList struct { Parameter Answer } // para 是参数 // one 代表第一个参数 type Parameter struct { nums1 []int nums2 []int } // ans 是答案 // one 代表第一个答案 type Answer struct { one float64 } func main() { question_list := []QuestionList{ { Parameter{[]int{400}, []int{111, 222, 333, 444, 555, 666, 777}}, Answer{422}, }, { Parameter{[]int{700}, []int{111, 222, 333, 444, 555, 666, 777}}, Answer{499.5}, }, { Parameter{[]int{600}, []int{111, 222, 333, 444, 555, 666, 777}}, Answer{499.5}, }, { Parameter{[]int{500}, []int{111, 222, 333, 444, 555, 666, 777}}, Answer{472}, }, { Parameter{[]int{1, 3, 5, 7, 9}, []int{2, 3, 4, 7, 11, 13}}, Answer{3.5}, }, { Parameter{[]int{1, 3}, []int{2}}, Answer{2.0}, }, { Parameter{[]int{1, 2}, []int{3, 4}}, Answer{2.5}, }, } fmt.Printf(\"------------------------Leetcode Problem 4------------------------\\n\") for _, question := range question_list { // 問題參數  Ans, Param := question.Answer, question.Parameter fmt.Printf(\"【input】:%+v answer:%+v 【output】:%+v\\n\", Param, Ans, findMedianSortedArrays(Param.nums1, Param.nums2)) } fmt.Printf(\"\\n\\n\\n\") } func findMedianSortedArrays(nums_list_1 []int, nums_list_2 []int) float64 { // 假设 nums1 的长度小  if len(nums_list_1) \u003e len(nums_list_2) { // 若數字清單 1 長度大於數字清單 2，將清單較短的數字清單 2 優先傳入第一個參數  return findMedianSortedArrays(nums_list_2, nums_list_1) } // 「數字清單 1」左方數字索引  num1_left_num_index := 0 // 「數字清單 1」右方數字索引  num1_right_nums_index := len(nums_list_1) // 所有數字中位數可能位置，全部長度+1，bit 往右位移除 2  all_nums_list_divide_position := (len(nums_list_1) + len(nums_list_2) + 1) \u003e\u003e 1 // 「數字清單 1」中位數位置  nums1_median_index := 0 // 「數字清單 2」中位數位置  nums2_median_index := 0 // === 中位數區塊劃分 ===  for num1_left_num_index \u003c= num1_right_nums_index { // 「當左方數字索引」比「右方數字索引」還要小，表示搜尋的數字還沒交叉重複到  // 數字清單 1 中位數位置 = 目前左方最小數字位置 + 右方剩餘數字取中位數 bit 往右位移(除 2)  // 中位數分界點，左側是 median_index -1，右側是 median_index，  // nums1: ……………… nums1[nums1_median_index-1] | nums1[nums1_median_index] ……………………  // nums2: ……………… nums2[nums2_median_index-1] | nums2[nums2_median_index] ……………………  nums1_median_index = num1_left_num_index + (num1_right_nums_index-num1_left_num_index)\u003e\u003e1 // 數字清單 2 中位數位置 = 所有數字中位數可能位置 - 數字清單 1 中位數位置  nums2_median_index = all_nums_list_divide_position - nums1_median_index if nums1_median_index \u003e 0 \u0026\u0026 nums_list_1[nums1_median_index-1] \u003e nums_list_2[nums2_median_index] { // nums1 中的分界线划多了，要向左边移动  // 「數字清單 1」中位數位置不是第一個數字  // 「數字清單 1」中位數左側數字比「數字清單 2」右側中位數還大（排序過的數字左側應比右側小）  // 表示整個數字列表的中位數在「數字清單 1」目前中位數之前  // 「數字清單 1」右方數字索引往左側移動，找「數字清單 1」中位數前面小一點的數字  num1_right_nums_index = nums1_median_index - 1 } else if nums1_median_index != len(nums_list_1) \u0026\u0026 nums_list_1[nums1_median_index] \u003c nums_list_2[nums2_median_index-1] { // nums1 中的分界线划少了，要向右边移动  // 「數字清單 1」中位數位置不是最後一個數字  // 「數字清單 1」中位數右側數字比「數字清單 2」左側中位數還小（排序過的數字右側應比左側大）  // 「數字清單 1」中位數位置數字 比 「數字清單 2」中位數位位置的前一個數字還小  // 「數字清單 1」左方數字索引往右側移動，找「數字清單 1」中位數後面大一點的數字  num1_left_num_index = nums1_median_index + 1 } else { // 無法再劃分左右側中位數位置  break } } // === 找出中位數 ===  // 中位數  var median_num float64 = 0.0 // 左側中位數  median_num_left := 0 // 右側中位數  median_num_right := 0 if nums1_median_index == 0 { // 「數字清單 1」中位數位置為第一個數字  // 中位數左側數字 = 「數字清單 2」 左側第一個數字」  median_num_left = nums_list_2[nums2_median_index-1] } else if nums2_median_index == 0 { // 「數字清單 2」中位數位置為第一個數字  // 中位數左側數字 = 「數字清單 1」 左側第一個數字」  median_num_left = nums_list_1[nums1_median_index-1] } else { // 中位數左側數字 = 「數字清單 1 左側位置第一個數字」與「數字清單 2 左側位置第一個數字」取最大的數字  // 左側的數字比右側小，所以要找比較大的數字才會接近右側數字  median_num_left = max(nums_list_1[nums1_median_index-1], nums_list_2[nums2_median_index-1]) } // 判斷數字數量是奇數還是偶數  if (len(nums_list_1)+len(nums_list_2))\u00261 == 1 { // 若數字總數量為奇數，直接回傳中位數數字  median_num = float64(median_num_left) return median_num } if nums1_median_index == len(nums_list_1) { // 「數字清單 1」中位數位置在不在清單中，索引超出清單長度（索引從 0 開始算）  // 中位數右側數字 = 「數字清單 2」中位數右側第一個數字  median_num_right = nums_list_2[nums2_median_index] } else if nums2_median_index == len(nums_list_2) { // 「數字清單 2」中位數位置在不在清單中，索引超出清單長度（索引從 0 開始算）  // 中位數右側數字 = 「數字清單 1」中位數右側第一個數字  median_num_right = nums_list_1[nums1_median_index] fmt.Println(\"\u003cmedian_num_right (2)\u003e: num1_medium =\u003e nums_list_1[nums1_median_index]\") } else { // 中位數右側數字 = 「數字清單 1 右側第一個數字」與「數字清單 2 右側第一個數字」取最小的數字  // 右側的數字比左側大，所以要找比較小的數字才會接近左側數字  median_num_right = min(nums_list_1[nums1_median_index], nums_list_2[nums2_median_index]) } median_num = float64(median_num_left+median_num_right) / 2 return median_num } func max(a int, b int) int { if a \u003e b { return a } return b } func min(a int, b int) int { if a \u003e b { return b } return a } 參考資料  Binary Search : Median of two sorted arrays of different sizes. - YouTube Median of Two Sorted Arrays - LeetCode 0004. Median of Two Sorted Arrays | LeetCode Cookbook  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0004 - Median of Two Sorted Arrays"],"description":"Golang Leetcode 問題: 0004 - Median of Two Sorted Arrays","excerpt":"Golang Leetcode 問題: 0004 - Median of Two Sorted Arrays","ref":"/leetcode/question/0001-0100/0004-median-of-two-sorted-arrays./","tags":["Golang","教學文件","新手教學","Leetcode","問題","0004 - Median of Two Sorted Arrays"],"title":"0004 - Median of Two Sorted Arrays"},{"body":"","categories":["Golang","教學文件","新手教學","Leetcode","問題"],"description":"Golang Leetcode 問題: 0001~0100","excerpt":"Golang Leetcode 問題: 0001~0100","ref":"/leetcode/question/0001-0100/","tags":["Golang","教學文件","新手教學","Leetcode","問題"],"title":"0001~0100"},{"body":"","categories":["Golang","教學文件","新手教學","Leetcode","問題"],"description":"Golang Leetcode 問題: 0101~0200","excerpt":"Golang Leetcode 問題: 0101~0200","ref":"/leetcode/question/0101-0200/","tags":["Golang","教學文件","新手教學","Leetcode","問題"],"title":"0101~0200"},{"body":"列印陣列 僅用到陣列 value 數值 nums := []int{2, 3, 4} sum := 0 for _, value := range nums { sum += value } fmt.Println(\"sum:\", sum) 列印陣列 key 及 value var name_list = []string{`Golang`, `Python`, `PHP`} for key, value := range name_list { fmt.Printf(\"language key: %d = %s\\n\", key, value) } // language key: 0 = Golang // language key: 1 = Python // language key: 2 = PHP arr1 := [3][2]int{{1, 2}, {3, 4}, {5, 6}} fmt.Println(arr1) // [[1 2] [3 4] [5 6]]  for key, value := range arr1 { fmt.Printf(\"%d =\u003e %d\\n\", key, value) } // 0 =\u003e [1 2] // 1 =\u003e [3 4] // 2 =\u003e [5 6] ","categories":["Golang","教學文件","新手教學","基礎","for range 迴圈"],"description":"Golang 基礎: for range 迴圈","excerpt":"Golang 基礎: for range 迴圈","ref":"/basic/loop/range/","tags":["Golang","教學文件","新手教學","基礎","for range 迴圈"],"title":"for range"},{"body":"for 一般迴圈 for j := 7; j \u003c= 9; j++ { fmt.Println(j) } // 7 // 8 // 9 for 外部設定初始值  有點類似 while 迴圈\n i := 1 for i \u003c= 3 { fmt.Println(i) i = i + 1 } // 1 // 2 // 3 for 無窮迴圈  若沒有 break 掉的話，會是無窮的迴圈，有點類似 while 迴圈\n for { fmt.Println(\"infinite loop\") break } ","categories":["Golang","教學文件","新手教學","基礎","for 迴圈"],"description":"Golang 基礎: for 迴圈","excerpt":"Golang 基礎: for 迴圈","ref":"/basic/loop/for/","tags":["Golang","教學文件","新手教學","基礎","for 迴圈"],"title":"for"},{"body":"一般變數宣告 一般變數宣告預設值 var num int = 0 var num int 一般變數宣告指定值 var num int = 10 var num = 10 單行宣告  應少用，程式碼可讀性不高\n var name, age, height = \"KJ\", 18, 199.9 多行宣告 var ( name = \"KJ\" age = 18 height = 199.9 ) 多行宣告加入型態 var ( name string = \"KJ\" age uint = 18 height float32 = 199.9 ) 多行宣告沒有設定預設值 var ( name string age uint height float32 ) 短變數宣告 name := \"KJ\" age := 18 height := 199.9 單行短變數宣告  應少用，程式碼可讀性不高\n name, age, height := \"KJ\", 18, 199.9 常數變數宣告 一般常數宣告 const AGE int = 18 單行常數宣告  應少用，程式碼可讀性不高\n const AUTHOR, AGE = \"KJ\", 18 多行常數宣告 const ( AUTHOR = \"KJ\" AGE = 18 ) 參考資料  Go by Example: Variables Go by Example: Constants  ","categories":["Golang","教學文件","新手教學","基礎","一般變數"],"description":"Golang 基礎: 一般變數","excerpt":"Golang 基礎: 一般變數","ref":"/basic/data-type/normal/","tags":["Golang","教學文件","新手教學","基礎","一般變數"],"title":"一般"},{"body":"跳脫字元    類型 說明     “雙引號” 可跳脫字元   `重音符` 保留原始字串    a := \"雙引號:可跳脫字元\\t \\n等\" b := `重音符:保留原始字串 \\t \\n 等` fmt.Println(a) fmt.Println(b) // 雙引號:可跳脫字元 // 等 // 重音符:保留原始字串 \\t \\n 等 列印函數 print    類型 說明 description     fmt.Print 列印 print   fmt.Println 列印 + 換行 print + new line   fmt.Printf 格式化列印(沒有換行) format print    fmt.Print 列印 a := `KJ` fmt.Print(a) fmt.Print(a) fmt.Print(a) // KJKJKJ fmt.Println 列印 + 換行 a := `KJ` fmt.Println(a) fmt.Println(a) fmt.Println(a) // KJ // KJ // KJ fmt.Printf 格式化列印 a := `KJ` fmt.Printf(\"a: %v type: %T\\n\", a, a) // a: KJ type: string 儲存列印字串 sprint    類型 說明 description     fmt.str2 儲存列印字串 save print string   fmt.Sprintln 儲存列印字串 + 換行 save print string + new line   fmt.Sprintf 儲存列印格式化字串(沒有換行) save format print string    fmt.Sprint 儲存列印字串 s1 := \"I\" s2 := \"am\" s3 := \"KJ\" str2 := fmt.Sprint(s1, s2, s3) fmt.Println(str2) // IamKJ fmt.Sprintln 儲存列印字串 + 換行  相鄰變數會用空格串接，字串最後會加上換行符號\n s1 := \"I\" s2 := \"am\" s3 := \"KJ\" // 將字串格式化儲存 str1 := fmt.Sprintln(s1, s2, s3) fmt.Println(str1) // I am KJ  fmt.Sprintf 儲存列印格式化字串 name := `KJ` age := 18 introduction := fmt.Sprintf(\"My name is %v. I'm %d years old\\n\", name, age) fmt.Printf(\"Developer said: %s\", introduction) // Developer said: My name is KJ. I'm 18 years old 參考資料  fmt - The Go Programming Language Println vs Printf vs Print in Go - Stack Overflow Go 学习笔记（46）— Go 标准库之 fmt（输入/输出格式化参数、Printf/Fprintf/Sprintf区别、Println/Fprintln/Sprintln 区别）_wohu1104的专栏-CSDN博客 # Day06 Go開教基本語法 (fmt) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天  ","categories":["Golang","教學文件","新手教學","基礎","列印"],"description":"Golang 基礎: 列印","excerpt":"Golang 基礎: 列印","ref":"/basic/print/","tags":["Golang","教學文件","新手教學","基礎","列印"],"title":"列印"},{"body":"一般    類型 說明 description     %v 預設格式 default format   %+v 預設格式加上欄位名稱 default format with field names   %#v golang 語法格式 Go-syntax format   %T golang 資料類型 Go-syntax type of value   %% 百分比符號 percent sign    預設格式 %v a := 26 fmt.Printf(\"a: %v\\n\", a) // a: 26 a := `KJ` fmt.Printf(\"a: %v\\n\", a) // a: KJ type Developer struct { name string age int is_working bool } func main() { fmt.Printf(\"Developer: %v\\n\", Developer{}) // Developer: { 0 false} } 預設格式加上欄位名稱 %+v type Developer struct { name string age int is_working bool } func main() { fmt.Printf(\"Developer: %+v\\n\", Developer{}) // Developer: {name: age:0 is_working:false} } golang 語法格式 %#v a := 26 fmt.Printf(\"a: %#v\\n\", a) // a: 26 a := `KJ` fmt.Printf(\"a: %#v\\n\", a) // a: \"KJ\" var a = []float64{1, 2, 4, 8, 16, 32, 64, 128} fmt.Printf(\"a: %#v\\n\", a) // a: []float64{1, 2, 4, 8, 16, 32, 64, 128} type Developer struct { name string age int is_working bool } func main() { fmt.Printf(\"Developer: %#v\\n\", Developer{}) // Developer: main.Developer{name:\"\", age:0, is_working:false} } golang 資料類型 %T var a = []float64{1, 2, 4, 8, 16, 32, 64, 128} fmt.Printf(\"a: %T\\n\", a) // a: []float64 a := 26 fmt.Printf(\"a: %T\\n\", a) // a: int a := `KJ` fmt.Printf(\"a: %T\\n\", a) // a: string 百分比符號 %% fmt.Printf(\"percent sign: %%\\n\") // percent sign: % 布林值    類型 說明 description     %t 布林值 true or false    布林值 %t a := true fmt.Printf(\"a: %t\\n\", a) // a: true a := 1 fmt.Printf(\"a: %t\\n\", a) // a: %!t(int=1) a := `KJ` fmt.Printf(\"a: %t\\n\", a) // a: %!t(string=KJ) 整數    類型 說明 description     %d 十進位數字 base 10   %b 二進位數字 base 2   %o 八進位數字 base 8   %O 八進位數字 base 8 with 0o prefix   %x 十六進位數字(小寫) base 16 with lower-case   %X 十六進位數字(大寫) base 16 with upper-case   %c 字元 ASCII 字元   %s 字串 一般字串   %U Unicode -    十進位數字 %d a := 10 fmt.Printf(\"a: %d\\n\", a) // a: 10 二進位數字 %b a := 10 fmt.Printf(\"a: %b\\n\", a) // a: 1010 八進位數字 %o %O a := 10 fmt.Printf(\"a: %o\\n\", a) // a: 12 a := 10 fmt.Printf(\"a: %O\\n\", a) // a: 0o12 十六進位數字 %x %X a := 26 fmt.Printf(\"a: %x\\n\", a) // a: 1a a := 26 fmt.Printf(\"a: %X\\n\", a) // a: 1A 字串 %s a := `KJ` fmt.Printf(\"a: %s\\n\", a) // a: KJ a := 75 fmt.Printf(\"a: %s\\n\", a) // a: %!s(int=75) ASCII 字元 %c a := 75 fmt.Printf(\"a: %c\\n\", a) // a: K Unicode 字元 %U a := 26 fmt.Printf(\"a: %U\\n\", a) // a: U+001A 參考資料  fmt - The Go Programming Language # Day06 Go開教基本語法 (fmt) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天  ","categories":["Golang","教學文件","新手教學","基礎","列印格式"],"description":"Golang 基礎: 列印格式","excerpt":"Golang 基礎: 列印格式","ref":"/basic/print/format/","tags":["Golang","教學文件","新手教學","基礎","列印格式"],"title":"格式"},{"body":"產生亂數 // 產生亂數種子 rand.Seed(time.Now().UnixNano()) // 1648566969196745000 fmt.Println(rand.Int()) 隨機取清單資料 package main import ( \"fmt\" \"math/rand\" \"time\" ) // 員工清單 var EmployeeList = []string{ \"Kay\", \"Jay\", \"KJ\", } type Generator struct { rand *rand.Rand } // 產生名稱 func (generator *Generator) Name() string { // 清單長度 \tlength := len(EmployeeList) // 隨機取清單資料 \treturn EmployeeList[generator.rand.Intn(length)] } // 建立產生器 func CreateEmployeeGenerator() Generator { // 產生種子 \tr := rand.New(rand.NewSource(time.Now().UnixNano())) // 設定產生器種子 \treturn Generator{ rand: r, } } func main() // 建立產生器 \tEmployeeGenerator := CreateEmployeeGenerator() // 隨機列印清單資料 \tfor i := 0; i \u003c 10; i++ { fmt.Println(EmployeeGenerator.Name()) } } 最後輸出的資料是隨機的清單資料\nJay Jay Jay KJ Kay Kay KJ KJ Kay KJ ","categories":["Golang","教學文件","新手教學","基礎","數學","亂數"],"description":"Golang 基礎: 亂數","excerpt":"Golang 基礎: 亂數","ref":"/basic/math/rand/","tags":["Golang","教學文件","新手教學","基礎","數學","亂數"],"title":"亂數"},{"body":"題目 傳入排序過的數字陣列，並移除重複的數字\n答案 func removeDuplicates(nums_list []int) int { if len(nums_list) == 0 { // 若沒有數字資料  return 0 } // 數字清單長度  num_list_length := len(nums_list) // 最大數字所在索引  max_num_index := num_list_length -1 // 最後一個非重複數字索引  last_none_duplicate_num_index := 0 // 非重複數字搜尋索引  non_duplicate_num_finder_index := 0 for last_none_duplicate_num_index \u003c max_num_index { // 最後一個非重複數字索引不是最後一個項目，繼續往後找  for nums_list[non_duplicate_num_finder_index] == nums_list[last_none_duplicate_num_index] { // 若持續找到相同的數字，繼續往後找，直到數字不同在跳出  non_duplicate_num_finder_index++ if non_duplicate_num_finder_index == num_list_length { // 找到最後一個項目，非重複的長度為最後一個項目索引 +1  return last_none_duplicate_num_index + 1 } } // 將非重複元素索引往後移動  last_none_duplicate_num_index++ // 找到不同的元素了，將找到的不同元素複製到前方  nums_list[last_none_duplicate_num_index] = nums_list[non_duplicate_num_finder_index] } return last_none_duplicate_num_index + 1 } 完整程式碼 package main import ( \"fmt\" ) type QuestionList struct { Parameter Answer } // Parameter 是参数 // nums_list 代表第一个参数 type Parameter struct { nums_list []int } // Answer 是答案 // nums 代表第一个答案 type Answer struct { nums int } func main() { question_list := []QuestionList{ { Parameter{[]int{1, 1, 2}}, Answer{2}, }, { Parameter{[]int{0, 0, 1, 1, 1, 1, 2, 3, 4, 4}}, Answer{5}, }, { Parameter{[]int{0, 0, 0, 0, 0}}, Answer{1}, }, { Parameter{[]int{1}}, Answer{1}, }, } fmt.Printf(\"------------------------Leetcode Problem 26------------------------\\n\") for _, question := range question_list { Ans, Param := question.Answer, question.Parameter fmt.Printf(\"【input】:%v answer:%+v 【output】:%v\\n\", Param.nums_list, Ans.nums, removeDuplicates(Param.nums_list)) } } func removeDuplicates(nums_list []int) int { if len(nums_list) == 0 { // 若沒有數字資料  return 0 } // 數字清單長度  num_list_length := len(nums_list) // 最大數字所在索引  max_num_index := num_list_length -1 // 最後一個非重複數字索引  last_none_duplicate_num_index := 0 // 非重複數字搜尋索引  non_duplicate_num_finder_index := 0 for last_none_duplicate_num_index \u003c max_num_index { // 最後一個非重複數字索引不是最後一個項目，繼續往後找  for nums_list[non_duplicate_num_finder_index] == nums_list[last_none_duplicate_num_index] { // 若持續找到相同的數字，繼續往後找，直到數字不同在跳出  non_duplicate_num_finder_index++ if non_duplicate_num_finder_index == num_list_length { // 找到最後一個項目，非重複的長度為最後一個項目索引 +1  return last_none_duplicate_num_index + 1 } } // 將非重複元素索引往後移動  last_none_duplicate_num_index++ // 找到不同的元素了，將找到的不同元素複製到前方  nums_list[last_none_duplicate_num_index] = nums_list[non_duplicate_num_finder_index] } return last_none_duplicate_num_index + 1 } 參考資料  Remove Duplicates from Sorted Array - LeetCode 0026. Remove Duplicates From Sorted Array | LeetCode Cookbook  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0026 - Remove Duplicates from Sorted Array"],"description":"Golang Leetcode 問題: 0026 - Remove Duplicates from Sorted Array","excerpt":"Golang Leetcode 問題: 0026 - Remove Duplicates from Sorted Array","ref":"/leetcode/question/0001-0100/0026-remove-duplicates-from-sorted-array/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0026 - Remove Duplicates from Sorted Array"],"title":"0026 - Remove Duplicates from Sorted Array"},{"body":"設定本機環境變數 為了要讓本機環境可以直接使用到透過 go 安裝的套件，可以在 ~/.bash_profile 或 ~/.zshrc 中加上\n# ~/.zshrc export GOPATH=$HOME/go export PATH=$PATH:$GOPATH/bin ","categories":["Golang","教學文件","新手教學","基礎","安裝"],"description":"Golang 基礎: 安裝","excerpt":"Golang 基礎: 安裝","ref":"/basic/environment/install/","tags":["Golang","教學文件","新手教學","基礎","安裝"],"title":"安裝"},{"body":"二進制位元運算\n運算符    運算符 簡述 說明     \u0026 AND 運算 要 全部 數值都為 1，運算後才為 1   | OR 運算 其中 一數值為 1，運算後才為 1   ^ XOR 運算 兩個數值不相同（0 or 1），運算後才為 1    運算範例 \u0026 : AND 運算  要 全部 數值都為 1，運算後才為 1\n    項目 數值 數值 數值 數值     bits_1 0 0 1 1   bits_2 0 1 0 1   bits_1 \u0026 bits_2 (AND 運算) 0 0 0 1    | : OR 運算  其中 一數值為 1，運算後才為 1\n    項目 數值 數值 數值 數值     bits_1 0 0 1 1   bits_2 0 1 0 1   bits_1 | bits_2 (OR 運算) 0 1 1 1    ^ : XOR 運算  兩個數值不相同（0 or 1），運算後才為 1\n    項目 數值 數值 數值 數值     bits_1 0 0 1 1   bits_2 0 1 0 1   bits_1 ^ bits_2 (XOR 運算) 0 1 1 0    ","categories":["Golang","教學文件","新手教學","基礎","運算元","Operators","位元 bits 運算"],"description":"Golang 基礎: 運算元 Operators 位元 bits 運算","excerpt":"Golang 基礎: 運算元 Operators 位元 bits 運算","ref":"/basic/operators/bits/","tags":["Golang","教學文件","新手教學","基礎","運算元","Operators","位元 bits 運算"],"title":"位元 bits 運算"},{"body":"陣列 指定陣列大小 var arr [5]int arr[0] = 1 arr[1] = 2 arr[4] = 5 fmt.Println(arr) // [1 2 0 0 5] arr := [5]int{1, 2, 3} fmt.Println(arr) // [1 2 3 0 0] 不指定陣列大小 arr := [...]int{1, 2, 3, 4, 5} fmt.Println(arr) // [1 2 3 4 5] 巢狀陣列 var arr [3][2]int fmt.Println(arr) // [[0 0] [0 0] [0 0]] 指定巢狀陣列預設值 arr1 := [3][2]int{{1, 2}, {3, 4}, {5, 6}} fmt.Println(arr1) // [[1 2] [3 4] [5 6]]  arr2 := [...][2]int{{1, 2}, {3, 4}, {5, 6}} fmt.Println(arr2) // [[1 2] [3 4] [5 6]] 複製陣列 限制陣列長度 arr := [5]int{1, 2, 3, 4, 5} // 指定要複製的陣列 var arr_copy [5]int arr_copy = arr arr_copy[3] = 99 fmt.Println(arr) // [1 2 3 4 5] fmt.Println(arr_copy) // [1 2 3 99 5] 不限制陣列長度  複製的陣列會變成傳址的方式\n arr := []int{1, 2, 3, 4, 5, 6, 7} var arr_copy []int arr_copy = arr arr_copy[3] = 99 fmt.Println(arr) // [1 2 3 99 5 6 7] fmt.Println(arr_copy) // [1 2 3 99 5 6 7] 參考資料  Go by Example: Arrays [Golang] Slice and Array | PJCHENder 未整理筆記  ","categories":["Golang","教學文件","新手教學","基礎","陣列變數"],"description":"Golang 基礎: 陣列變數","excerpt":"Golang 基礎: 陣列變數","ref":"/basic/data-type/array/","tags":["Golang","教學文件","新手教學","基礎","陣列變數"],"title":"Array 陣列"},{"body":"","categories":["Golang","教學文件","新手教學","基礎"],"description":"Golang 基礎","excerpt":"Golang 基礎","ref":"/basic/","tags":["Golang","教學文件","新手教學","基礎"],"title":"基礎"},{"body":"整數    類型 min max 範圍     uint8 or byte 0 255 2^0 ~ 2^8   uint16 0 65585 2^0 ~ 2^16   uint32 or rune 0 4294967296 2^0 ~ 2^32   uint64 0 1.84467E+19 2^0 ~ 2^64   int8 -128 128 - 1 -2^7 ~ 2^7 - 1   int16 -32768 32768 - 1 -2^15 ~ 2^15 - 1   int32 -2147483648 2147483648 - 1 -2^31 ~ 2^31 - 1   int64 -9.22337E+18 9.22337E+18 - 1 -2^63 ~ 2^63 - 1    浮點數    類型 min max 範圍     float32 - - -1.410^-45 ~ 3.410^38   float64 - - -4.9410^-324 ~ 1.7910^308    參考資料  [Golang] 程式設計教學：資料型態 (Data Type) | Michael Chen 的技術文件  ","categories":["Golang","教學文件","新手教學","基礎","變數類型"],"description":"Golang 基礎: 變數類型","excerpt":"Golang 基礎: 變數類型","ref":"/basic/data-type/","tags":["Golang","教學文件","新手教學","基礎","變數類型"],"title":"變數類型"},{"body":"Array 與 Slice 使用情境比較  Array：清單的長度是固定的（fixed length），屬於原生型別（primitive type），較少在程式中使用。 Slice：可以增加或減少清單的長度，使用 [] 定義，例如，[]byte 是 byte slice，指元素為 byte 的 slice；[]string 是 string slice，指元素為 string 的 slice。  Slice 的 Pointer \u0026 capacity 及 length    項目 說明     Pointer (ptr) 這個 pointer 會指向實際上在底層的 array。   Capacity (cap) 從 slice 的第一個元素開始算起，它底層 array 的元素數目，cap 的數量再擴展時會是 1, 2, 4, 8, 16   Length (len) 該 slice 中的元素數目    使用 Slice 變數時，會先指向該 Slice，然後 Pointer (ptr) 會指向這個 Slice 對應的 Array\n建立 slice 變數 透過 make 可以建立「空 slice」  適合用會對 slice 中特定位置元素進行操作時\n  make(類型, 長度, capacity)\n employee_list := make([]string, 3) fmt.Println(\"empty employee_list:\", employee_list) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" fmt.Println(\"all employee:\", employee_list) fmt.Println(\"3rd employee:\", employee_list[2]) // empty employee_list: [ ] // all employee: [KJ Kay Jay] // 3rd employee: Jay 建立一個帶有資料的 string slice  適合用在知道 slice 裡面的元素有哪些時\n employee_list := []string{\"KJ\", \"Kay\", \"Jay\"} fmt.Println(\"all employee:\", employee_list) // all employee: [KJ Kay Jay] 空的 slice  一般會搭配 append 使用\n var employee_list []string employee_list = append(employee_list, \"KJ\") employee_list = append(employee_list, \"Kay\") employee_list = append(employee_list, \"Jay\") fmt.Println(\"all employee:\", employee_list) fmt.Println(\"3rd employee:\", employee_list[2]) // all employee: [KJ Kay Jay] // 3rd employee: Jay 其他類型 Slice // integer slice integer_slice := []int{2, 3, 5, 7, 11, 13} fmt.Println(integer_slice) // [2 3 5 7 11 13]  // boolean slice boolean_slice := []bool{true, false, true, true, false, true} // [true false true true false true] fmt.Println(boolean_slice) // struct slice struct_slice := []struct { number int is_exist bool }{ {2, true}, {3, false}, {5, true}, {7, true}, {11, false}, {13, true}, } // [{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}] fmt.Println(struct_slice) 多維度 Slice multi_dimension_slice := make([][]int, 3) // [[] [] []] fmt.Println(multi_dimension_slice) // 賦值 multi_dimension_slice[0] = []int{1} multi_dimension_slice[1] = []int{2} multi_dimension_slice[2] = []int{3} // [[1] [2] [3]] fmt.Println(multi_dimension_slice) multi_dimension_slice := [][]int{ []int{1}, []int{2}, []int{3}, } // [[1] [2] [3]] fmt.Println(multi_dimension_slice) Slice 與 Array 建立差異 // 沒有使用 ...，建立出來的會是 slice sliceList := []string{\"North\", \"East\", \"South\", \"West\"} // slice 4 fmt.Println(reflect.TypeOf(sliceList).Kind(), len(sliceList)) // 使用 ...，建立出來的會是 array arrayList := [...]string{\"North\", \"East\", \"South\", \"West\"} // array 4 fmt.Println(reflect.TypeOf(arrayList).Kind(), len(arrayList)) slice 資料數量 employee_list := make([]string, 3) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" fmt.Println(\"len:\", len(employee_list)) // len: 3 加入 slice 資料 加入單一資料到 slice employee_list := make([]string, 3) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" employee_list = append(employee_list, \"Musk\") employee_list = append(employee_list, \"Bill\", \"Jim\") fmt.Println(\"all employee after append:\", employee_list) // all employee after append: [KJ Kay Jay Musk Bill Jim] 加入另一 slice 變數資料 employee_list_slice := []string{\"KJ\", \"Kay\"} other_employee_slice := []string{\"Jay\", \"Jeff\"} // 等同於 append(employee_list_slice, other_employee_slice[0], other_employee_slice[1], other_employee_slice[2]) employee_list_slice = append(employee_list_slice, other_employee_slice...) // [KJ Kay Jay Jeff] fmt.Println(employee_list_slice) 複製 slice 變數  複製的 slice 變數是傳值的方式，所以複製變數的異動不會影響先前的 slice 變數\n  copy(目標變數, 來源變數) int\n copy() 回傳的值是複製了多少元素\nemployee_list := make([]string, 3) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" // 複製 slice 變數 copy_employee_list := make([]string, len(employee_list)) copy(copy_employee_list, employee_list) fmt.Println(\"all employee:\", employee_list) fmt.Println(\"all copy employee:\", copy_employee_list) // all employee: [KJ Kay Jay] // all copy employee: [KJ Kay Jay]  // 變更複製的 slice copy_employee_list[2] = \"Change Name\" fmt.Println(\"all employee after change:\", employee_list) fmt.Println(\"all copy employee after change:\", copy_employee_list) // all employee after change: [KJ Kay Jay] // all copy employee after change: [KJ Kay Change Name] 複製元素大小影響  cloneScores 的元素數量如果「多於」被複製進去的元素時，會用 zero value 去補 cloneScores 的元素數量如果「少於」被複製進去的元素時，超過的元素不會被複製進去  scores := []int{1, 2, 3, 4, 5} // STEP 1：建立空 slice cloneScoresMore := make([]int, 7) cloneScoresLess := make([]int, 3) // STEP 2：使用 copy 複製 scores 元素 copy(cloneScoresMore, scores) copy(cloneScoresLess, scores) // cloneScores 的元素數量如果「多於」被複製進去的元素時，會用 zero value 去補 // [1 2 3 4 5 0 0] fmt.Println(cloneScoresMore) // cloneScores 的元素數量如果「少於」被複製進去的元素時，超過的元素不會被複製進去 // [1 2 3] fmt.Println(cloneScoresLess) 取得指定 slice 範圍的變數 employee_list := make([]string, 6) employee_list[0] = \"KJ\" employee_list[1] = \"Kay\" employee_list[2] = \"Jay\" employee_list[3] = \"Musk\" employee_list[4] = \"Bill\" employee_list[5] = \"Jim\"  slice[\u003c從第幾個元素\u003e:\u003c到第幾個元素(不含此元素)\u003e]\n slice_employee_list := employee_list[2:5] fmt.Println(\"employee_list:\", employee_list) fmt.Println(\"slice_employee_list:\", slice_employee_list) // employee_list: [KJ Kay Jay Musk Bill Jim] // slice_employee_list: [Jay Musk Bill]   slice[:\u003c到第幾個元素(不含此元素)\u003e]\n slice_employee_list := employee_list[:3] fmt.Println(\"employee_list:\", employee_list) fmt.Println(\"slice_employee_list:\", slice_employee_list) // employee_list: [KJ Kay Jay Musk Bill Jim] // slice_employee_list: [KJ Kay Jay]  slice[\u003c從第幾個元素\u003e:]\n slice_employee_list := employee_list[2:] fmt.Println(\"employee_list:\", employee_list) fmt.Println(\"slice_employee_list:\", slice_employee_list) // employee_list: [KJ Kay Jay Musk Bill Jim] // slice_employee_list: [Jay Musk Bill Jim] 移除元素 移除最後一個元素 scores := []int{1, 2, 3, 4, 5} removeLastIndex := scores[:len(scores)-1] // [1,2,3,4] fmt.Println(removeLastIndex) 參考資料  Go by Example: Slices slice | golang 個人筆記和心得 Go编程模式：切片，接口，时间和性能 | 酷 壳 - CoolShell [Golang] Slice and Array | PJCHENder 未整理筆記  ","categories":["Golang","教學文件","新手教學","基礎","Slice 變數","進階陣列"],"description":"Golang 基礎: Slice 變數: 進階陣列","excerpt":"Golang 基礎: Slice 變數: 進階陣列","ref":"/basic/data-type/slice/","tags":["Golang","教學文件","新手教學","基礎","Slice 變數","進階陣列"],"title":"Slice 變數: 進階陣列"},{"body":"","categories":["Golang","教學文件","新手教學","常見問題","語言特性"],"description":"語言特性","excerpt":"語言特性","ref":"/question/feature/","tags":["Golang","教學文件","新手教學","常見問題","語言特性"],"title":"語言特性"},{"body":"接收不會用到的變數參數 在 golang 如果變數有宣告但沒有用到，在編譯的時候是無法順利編譯執行的\n像在 for range 迴圈我們會去取他的 key 跟 value，但 key 對我們來說可能是沒有要用到的變數，這樣執行會出現 key declared but not used 的訊息\nnums := []int{2, 3, 4} sum := 0 for key, value := range nums { sum += value } fmt.Println(\"sum:\", sum) // key declared but not used 對於沒有用途的變數可以用 底線 _ 取做變數指定，這樣就不會建立了不會用到的變數\nnums := []int{2, 3, 4} sum := 0 for _, value := range nums { sum += value } fmt.Println(\"sum:\", sum) // sum: 9 判斷鍵值是否存在 僅需要判斷資料是否存在，沒有需要使用該數值的話，可以將第一個參數設定為 底線 _，用第二個變數來判斷是否存在\nm := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 _, is_key2_exist := m[\"key_2\"] _, is_key3_exist := m[\"key_3\"] fmt.Println(\"is_key2_exist:\", is_key2_exist) fmt.Println(\"is_key3_exist:\", is_key3_exist) // is_key2_exist: true // is_key3_exist: false 參考資料  variables - What is “_,” (underscore comma) in a Go declaration? - Stack Overflow The blank identifier - Effective Go - The Go Programming Language  ","categories":["Golang","教學文件","新手教學","常見問題","語言特性","底線","underscore comma"],"description":"底線逗號 `_` underscore comma，空白識別字元 blank identifier","excerpt":"底線逗號 `_` underscore comma，空白識別字元 blank identifier","ref":"/question/feature/blank-identifier/","tags":["Golang","教學文件","新手教學","常見問題","語言特性","底線","underscore comma"],"title":"底線逗號 `_` underscore comma"},{"body":"建立 Map 變數  map[key 的類型]value 的類型\n m := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 fmt.Println(\"map:\", m) // map: map[key_1:7 key_2:13] 取得 Map 鍵值資料 m := make(map[string]int) m[\"key_1\"] = 7 v1 := m[\"key_1\"] fmt.Println(\"v1: \", v1) // v1: 7 Map 資料數量 len()  len(變數)\n m := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 fmt.Println(\"len:\", len(m)) // len: 2 刪除 Map 指定鍵值資料 delete()  delete(變數, 鍵值)\n m := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 fmt.Println(\"map:\", m) // map: map[key_1:7 key_2:13]  delete(m, \"key_1\") fmt.Println(\"map:\", m) // map: map[key_2:13] 判斷鍵值是否存在  變數資料, 是否存在 := map 變數[鍵值]\n 僅需要判斷資料是否存在，沒有需要使用該數值的話，可以將第一個參數設定為 底線 _，用第二個變數來判斷是否存在\nm := make(map[string]int) m[\"key_1\"] = 7 m[\"key_2\"] = 13 _, is_key2_exist := m[\"key_2\"] _, is_key3_exist := m[\"key_3\"] fmt.Println(\"is_key2_exist:\", is_key2_exist) fmt.Println(\"is_key3_exist:\", is_key3_exist) // is_key2_exist: true // is_key3_exist: false 直接指定數值 m := map[string]string{\"name\": `KJ`, \"age\": `18`} fmt.Println(\"developer:\", m) // developer: map[age:18 name:KJ] 使用 struct 型態在 map package main import \"fmt\" type Person struct { FirstName string LastName string } func main() { // 使用 make 建立 Map \tEmployeeMap := make(map[string]Person) EmployeeMap[\"KJ\"] = Person{ FirstName: \"Kay\", LastName: \"Jay\", } // map[KJ:{FirstName:Kay LastName:Jay}] \tfmt.Printf(\"%+v\\n\", EmployeeMap) } Map 和 Struct 的選擇    欄位 Map Struct     鍵值 所有的 key 都需要是相同型別 -   數值資料 所有的 value 都需要是相同型別 value 可以是不同型別   迭代 Key 有被 indexed，因此可以進行迭代，列出所有的 key-value pairs Key 沒有被 indexed，因此沒辦法透過迭代的方式列出所有的 key-value pair   變數傳遞方式 Reference Type Value Type   用途 通常用在資料集合關聯性非常強的資料，例如 colors 通常用在一個帶有多種屬性的東西，例如 person   資料定義 不用一開始就知道所有的 key 有哪些，因為可以後續新增和刪除 需要一開始就清楚定義所有的欄位    參考資料  Go by Example: Maps [Golang] maps | PJCHENder 未整理筆記  ","categories":["Golang","教學文件","新手教學","基礎","Map 變數","key-value 陣列"],"description":"Golang 基礎: Map 變數: key-value 陣列","excerpt":"Golang 基礎: Map 變數: key-value 陣列","ref":"/basic/data-type/map/","tags":["Golang","教學文件","新手教學","基礎","Map 變數","key-value 陣列"],"title":"Map 變數: key-value 陣列"},{"body":"","categories":["Golang","教學文件","新手教學","基礎","迴圈"],"description":"Golang 基礎: 迴圈","excerpt":"Golang 基礎: 迴圈","ref":"/basic/loop/","tags":["Golang","教學文件","新手教學","基礎","迴圈"],"title":"迴圈"},{"body":"參考資料  Go 语言运算符 | 菜鸟教程  ","categories":["Golang","教學文件","新手教學","基礎","運算元","Operators"],"description":"Golang 基礎: 運算元 Operators","excerpt":"Golang 基礎: 運算元 Operators","ref":"/basic/operators/","tags":["Golang","教學文件","新手教學","基礎","運算元","Operators"],"title":"運算元"},{"body":"","categories":["Golang","教學文件","新手教學","基礎","函式"],"description":"Golang 基礎: 函式","excerpt":"Golang 基礎: 函式","ref":"/basic/function/","tags":["Golang","教學文件","新手教學","基礎","函式"],"title":"函式"},{"body":"函式指定給變數 package main import \"fmt\" func main() { // 函式指定給變數 \taddFunction := func(a int, b int) int { return a + b } // 呼叫變數函式 \tsum := addFunction(1, 2) // 3 \tfmt.Println(sum) } Closure 閉包函式 package main import \"fmt\" func addFunction() func(a, b int) int { baseNumber := 10 // baseNumber In addFunction() 0xc0000180c8 = 10 \tfmt.Printf(\"baseNumber In addFunction() %p = %d\\n\", \u0026baseNumber, baseNumber) return func(a, b int) int { // baseNumber In addFunction() closure 0xc0000180c8 = 10 \tfmt.Printf(\"baseNumber In addFunction() closure %p = %d\\n\", \u0026baseNumber, baseNumber) return func(a, b int) int { // baseNumber In addFunction() closure's closure 0xc0000180c8 = 10 \tfmt.Printf(\"baseNumber In addFunction() closure's closure %p = %d\\n\", \u0026baseNumber, baseNumber) return baseNumber + a + b }(a, b) } } func main() { sum := addFunction()(1, 2) // 13 \tfmt.Println(sum) } 最後輸出的資料會長得像這樣\nbaseNumber In addFunction() 0xc0000180c8 = 10 baseNumber In addFunction() closure 0xc0000180c8 = 10 baseNumber In addFunction() closure's closure 0xc0000180c8 = 10 13 baseNumber 的變數在整個 Closure 裡面都可以取用，且都是指都一個變數\n","categories":["Golang","教學文件","新手教學","基礎","匿名函式"],"description":"Golang 基礎: 匿名函式","excerpt":"Golang 基礎: 匿名函式","ref":"/basic/function/anonymous-function/","tags":["Golang","教學文件","新手教學","基礎","匿名函式"],"title":"匿名函式"},{"body":"","categories":["Golang","教學文件","新手教學","常見問題","Debug"],"description":"Debug","excerpt":"Debug","ref":"/question/debug/","tags":["Golang","教學文件","新手教學","常見問題","Debug"],"title":"Debug"},{"body":"在測試除錯時，想要中斷後面的程式，可以使用 os.Exit(0)\n中斷程式沒有錯誤代碼 去中斷整個程式的執行，參數為 0 實則不會列印出錯誤代碼\npackage main import ( \"fmt\" \"os\" ) func main() { fmt.Println(\"Hello World\") // 中斷程式 \tos.Exit(0) // 不會執行 \tfmt.Println(\"Something else...\") } 中斷程式含錯誤代碼 在 os.Exit(1) 帶入參數則可以顯示錯誤代碼\npackage main import ( \"fmt\" \"os\" ) func main() { fmt.Println(\"Exits with status code 1\") // 列印錯誤代碼 \tos.Exit(1) } 參考資料  Exit an Application, With or Without an Error Code · GolangCode Exit with error code in go? - Stack Overflow  ","categories":["Golang","教學文件","新手教學","常見問題","Debug","中斷程式"],"description":"中斷程式","excerpt":"中斷程式","ref":"/question/debug/exit-application/","tags":["Golang","教學文件","新手教學","常見問題","Debug","中斷程式"],"title":"中斷程式"},{"body":"新增連結變數 type Developer struct { name string // 姓名 \tage int // 年齡 \tNextDeveloper *Developer } 使用 new 新增 NewDeveloper := new(Developer) 使用 \u0026 新增並給予預設值 var NewDeveloper *Developer = \u0026Developer{ name: \"KJ\", age: 17, } TestDeveloper := \u0026Developer{ name: \"KJ\", age: 17, } 輪詢鏈結資料 package main import ( \"fmt\" ) type Developer struct { name string // 姓名 \tage int // 年齡 \tNextDeveloper *Developer } func main() { // 第 1 位工程師節點 \tvar FirstDeveloper *Developer = \u0026Developer{ name: \"KJ\", age: 17, } // 第 2 位工程師節點 \tvar SecondDeveloper *Developer = \u0026Developer{ name: \"Kay\", age: 19, } // 第 3 位工程師節點 \tvar ThirdDeveloper Developer ThirdDeveloper.name = `Jay` ThirdDeveloper.age = 23 // 插入「第 2 位工程師節點位址」到「第 1 位工程師節點」的 NextDeveloper 變數中 \tFirstDeveloper.NextDeveloper = SecondDeveloper // 插入「第 3 位工程師節點位址」到「第 2 位工程師節點」的 NextDeveloper 變數中 \tSecondDeveloper.NextDeveloper = \u0026ThirdDeveloper // 建立變數，搜尋節點資訊，並指向「第 1 位工程師節點」 \tSearchDeveloper := FirstDeveloper // 只要搜尋的節點中的資訊不為空，就會列印節點資訊 \tfor SearchDeveloper != nil { // fmt.Println(*SearchDeveloper) \tfmt.Printf(\"Developer: %+v\\n\", SearchDeveloper) //將欲查看的下個節點 指向 已查看完節點的Next字段 \tSearchDeveloper = SearchDeveloper.NextDeveloper } } // Developer: \u0026{name:KJ age:17 NextDeveloper:0xc0000b8020} // Developer: \u0026{name:Kay age:19 NextDeveloper:0xc0000b8040} // Developer: \u0026{name:Jay age:23 NextDeveloper:\u003cnil\u003e} 參考資料  Linked List in Go (Golang) - golangprograms.com Go by Example: Pointers Golang資料結構-day14-鏈表(Linked list) | Taroballz StudyNotes list - The Go Programming Language #21 鏈結串列 Linked-list | Golang魔法使 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 Container 3兄弟-List - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 [Golang] 程式設計教學：泛型 (Generics) 相關的議題 | Michael Chen 的技術文件  ","categories":["Golang","教學文件","新手教學","基礎","Linked list","鏈表"],"description":"Golang 基礎: Linked list 變數: 鏈表","excerpt":"Golang 基礎: Linked list 變數: 鏈表","ref":"/basic/data-type/linked-list/","tags":["Golang","教學文件","新手教學","基礎","Linked list","鏈表"],"title":"Linked list 變數: 鏈表"},{"body":"目前時間 package main import ( \"fmt\" \"time\" ) func main() { nowTime := time.Now() // 2022-03-29 23:13:42.52145 +0800 CST m=+0.000110810 \tfmt.Println(nowTime) } 奈秒 package main import ( \"fmt\" \"time\" ) func main() { nowTimeUnixNano := time.Now().UnixNano() // 1648566969196745000 \tfmt.Println(nowTimeUnixNano) } ","categories":["Golang","教學文件","新手教學","基礎","時間"],"description":"Golang 基礎: 時間","excerpt":"Golang 基礎: 時間","ref":"/basic/time/","tags":["Golang","教學文件","新手教學","基礎","時間"],"title":"時間"},{"body":"   類型 說明     \u0026variable 會回傳該變數 value 的 address，表示給我這個變數值的「記憶體位置」   *pointer 會回傳該 address 的 value，表示給我這個記憶體位置指稱到的「值」    package main import \"fmt\" func changeNameByValue(name_value string) { name_value = `KJ` } func changeNameByPointer(name_pointer *string) { *name_pointer = `KJ` } func main() { name := `Nobody` fmt.Println(\"initial Name:\", name) // call by value \tchangeNameByValue(name) fmt.Println(\"after changeNameByValue:\", name) // call by reference \tchangeNameByPointer(\u0026name) fmt.Println(\"after changeNameByPointer:\", name) fmt.Println(\"Name pointer:\", \u0026name) } // initial Name: Nobody // after changeNameByValue: Nobody // after changeNameByPointer: KJ // Name pointer: 0xc000010240 參考資料  Go by Example: Pointers Go - Call by reference - Tutorialspoint  ","categories":["Golang","教學文件","新手教學","基礎","Pointer","指標","call by reference","call by value"],"description":"Golang 基礎: Pointer 變數 指標","excerpt":"Golang 基礎: Pointer 變數 指標","ref":"/basic/data-type/pointer/","tags":["Golang","教學文件","新手教學","基礎","Pointer","指標","call by reference","call by value"],"title":"Pointer 變數: 指標"},{"body":"查詢環境變數 使用 go env 即可查詢環境變數\n$ go env GO111MODULE=\"\" GOARCH=\"amd64\" GOBIN=\"\" GOCACHE=\"/Users/kj/Library/Caches/go-build\" GOENV=\"/Users/kj/Library/Application Support/go/env\" GOEXE=\"\" GOEXPERIMENT=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GOINSECURE=\"\" GOMODCACHE=\"/Users/kj/go/pkg/mod\" GONOPROXY=\"\" GONOSUMDB=\"\" GOOS=\"darwin\" GOPATH=\"/Users/kj/go\" GOPRIVATE=\"\" GOPROXY=\"https://proxy.golang.org,direct\" GOROOT=\"/usr/local/go\" GOSUMDB=\"sum.golang.org\" GOTMPDIR=\"\" GOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\" GOVCS=\"\" GOVERSION=\"go1.18\" GCCGO=\"gccgo\" GOAMD64=\"v1\" AR=\"ar\" CC=\"clang\" CXX=\"clang++\" CGO_ENABLED=\"1\" GOMOD=\"/dev/null\" GOWORK=\"\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -arch x86_64 -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/ww/_fvvfmxs3nl880tfcf5bydhh0000gn/T/go-build2503645920=/tmp/go-build -gno-record-gcc-switches -fno-common\" 環境變數說明    變數名稱 說明     GOPATH 在沒有使用 Go Modules 前，GOPATH 會是所有工作環境的根目錄   GOROOT Go 語言本身自己要用的東西，或是內建的函式庫，像是 Go 編譯成執行檔時所用的工具    GOPATH 包含三個資料夾：src、pkg、bin\n   目錄 說明     $GOPATH/bin 主要放的是當執行 go install 時， Go 編譯後的執行檔。一般來說會建議把這個資料夾加到系統上的 global $PATH 變數，如此直接在終端機中執行這些編譯後的執行檔   $GOPATH/pkg 包存一些編譯前的物件，已簡短編譯所需的時間，一般來說，開發者並不需要進來這裡。若在編譯時碰到錯誤，可以安心地把這個資料夾刪除，Go 會自己再建立新的   $GOPATH/src 原始碼    go get，它會把目標下載回來放在 src 裡\n設定與移除環境變數 # 使用 -w 設定環境變數 $ go env -w GOBIN=/somewhere/else/bin # 使用 -u 移除環境變數 $ go env -u GOBIN 參考資料  [Golang] 環境變數 environment variables | PJCHENder 未整理筆記  ","categories":["Golang","教學文件","新手教學","基礎","env 環境變數"],"description":"Golang 基礎: env 環境變數","excerpt":"Golang 基礎: env 環境變數","ref":"/basic/environment/env/","tags":["Golang","教學文件","新手教學","基礎","env 環境變數"],"title":"env 環境變數"},{"body":"structs 是在 GO 中的一種資料型態，它就類似 JavaScript 中的物件（Object）或是 Ruby 中的 Hash。\n格式 type \u003c結構名稱\u003e struct { \u003c鍵值1\u003e \u003c數值類型\u003e \u003c鍵值2\u003e \u003c數值類型\u003e } 建立 Struct // STEP 1：建立一個 person 型別，它本質上是 struct type Person struct { firstName string lastName string } // 等同於 type Person struct { firstName, lastName string } 根據資料輸入的順序決定誰是 firstName 和 lastName alex := Person{\"Alex\", \"Anderson\"} // {Alex Anderson} fmt.Println(alex) // {firstName:Alex lastName:Anderson} fmt.Printf(\"%+v\\n\", alex) 直接取得 struct 的 pointer alex := \u0026Person{\"Alex\", \"Anderson\"} // \u0026{Alex Anderson} fmt.Println(alex) // \u0026{firstName:Alex lastName:Anderson} fmt.Printf(\"%+v\\n\", alex) 指定 structure 鍵值數值（建議使用）  程式可讀性高，不會指定到錯誤的鍵值資料\n alex := Person{ firstName: \"Alex\", lastName: \"Anderson\", } // {Alex Anderson} fmt.Println(alex) // {firstName:Alex lastName:Anderson} fmt.Printf(\"%+v\\n\", alex) 先宣告再賦值 var alex Person alex.firstName = \"Alex\" alex.lastName = \"Anderson\" // {Alex Anderson} fmt.Println(alex) 巢狀 struct package main import \"fmt\" // STEP 1：定義外層 struct type Person struct { firstName string lastName string contact ContactInfo } // STEP 2：定義內層 struct type ContactInfo struct { email string phone string } func main() { // STEP 3：建立變數 \tKayJayPerson := Person{ firstName: \"Kay\", lastName: \"Jay\", contact: ContactInfo{ email: \"kay@jay.com\", phone: \"0900000000\", }, } AlexPerson := Person{ firstName: \"Alex\", lastName: \"Bob\", } // {firstName:Kay lastName:Jay contact:{email:kay@jay.com phone:0900000000}} \t// STEP 4：印出變數 \tfmt.Printf(\"%+v\\n\", KayJayPerson) // {firstName:Alex lastName:Bob contact:{email: phone:}} \tfmt.Printf(\"%+v\\n\", AlexPerson) } 在 struct 使用 interface package main import \"fmt\" type Salaried interface { getSalary() int } type Salary struct { basic int insurance int allowance int } func (s Salary) getSalary() int { return s.basic + s.insurance + s.allowance } type Employee struct { firstName, lastName string salary Salaried // 只要 salary 實作了 Salaried，就可以 Salaried interface type } func main() { ross := Employee{ firstName: \"Kay\", lastName: \"Jay\", // 因為 Salary struct 已經實作了 Salaried，因此可以當作 salary 的欄位值 \tsalary: Salary{ basic: 1000, insurance: 100, allowance: 50, }, } // Kay's salary is 1150 \tfmt.Println(\"Kay's salary is\", ross.salary.getSalary()) } 匿名 struct employee := struct { Name string }{ Name: \"KJ\", } // {KJ} fmt.Println(employee) // {Name:KJ} fmt.Printf(\"%+v\\n\", employee) struct 的比較 當兩個 struct 結構相同，數值相同，可以拿來做比較\npackage main import \"fmt\" type Person struct { FirstName string LastName string } func main() { Person1 := Person{ FirstName: \"Kay\", LastName: \"Jay\", } Person2 := Person{ FirstName: \"Kay\", LastName: \"Jay\", } // true \tfmt.Println(Person1 == Person2) } 直接定義使用 struct 函式 package main import ( \"fmt\" ) type People struct { name string age int } func (people People) Hello(other People) string { return `Hi! ` + other.name + `, I am ` + people.name } func main() { KayPeople := People{name: `Kay`} JayPeople := People{`Jay`, 18} // Hi! Kay, I am Jay \tfmt.Println(JayPeople.Hello(KayPeople)) // Hi! Jay, I am Kay \tfmt.Println(KayPeople.Hello(JayPeople)) } 在 func 前面有寫這個是 (people People) 結構的函式，所以 go 會直接將這個函式與 People struct 直接綁定再一起\n所以建立完 struct 變數即可直接呼叫這個 Hello 函數\n參考資料  [Golang] Struct | PJCHENder 未整理筆記  ","categories":["Golang","教學文件","新手教學","基礎","Struct 變數"],"description":"Golang 基礎: Struct 變數","excerpt":"Golang 基礎: Struct 變數","ref":"/basic/data-type/struct/","tags":["Golang","教學文件","新手教學","基礎","Struct 變數"],"title":"Struct 變數"},{"body":"題目 有 Person 及 Address 資料表，Person 不一定會有 Address\n在不管有沒有 Address 的條件撈取出 FirstName,LastName, City, State 欄位資料\nPerson 資料表\n   Column Name Type     PersonId int   FirstName varchar   LastName varchar    Address 資料表\n   Column Name Type     AddressId int   PersonId int   City varchar   State varchar    答案 # Write your MySQL query statement below SELECT `FirstName`, `LastName`, `City`, `State` FROM `Person` LEFT JOIN `Address` ON `Person`.`PersonId` = `Address`.`PersonId` 參考資料  Combine Two Tables - LeetCode  ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0175 - Combine Two Table"],"description":"Golang Leetcode 問題: 0175 - Combine Two Table","excerpt":"Golang Leetcode 問題: 0175 - Combine Two Table","ref":"/leetcode/question/0101-0200/0175-combine-two-table/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0175 - Combine Two Table"],"title":"0175 - Combine Two Table"},{"body":"題目 找出 Employee 資料表第二高薪的薪水\n 若沒有第二高薪水的話則回傳 null 若第一高有兩個人，薪水一樣高，但沒其他人了，則第二高為 null  Employee 資料表\n   Id Salary     1 100   2 200   3 300   4 100    # Write your MySQL query statement below SELECT( SELECT DISTINCT `Salary` FROM `Employee` ORDER BY `Salary` DESC LIMIT 1 OFFSET 1 ) as `SecondHighestSalary` ","categories":["Golang","教學文件","新手教學","Leetcode","問題","0176 - Second Highest Salary"],"description":"Golang Leetcode 問題: 0176 - Second Highest Salary","excerpt":"Golang Leetcode 問題: 0176 - Second Highest Salary","ref":"/leetcode/question/0101-0200/0176-second-highest-salary/","tags":["Golang","教學文件","新手教學","Leetcode","問題","0176 - Second Highest Salary"],"title":"0176 - Second Highest Salary"},{"body":"byte 是 uint8 的別名\nByte 與 String 比較 Byte 可以 改其中之一的值\n// ok TextByte := []byte(\"Hello Kay Jay!\") TextByte[1] = 'T' String 不可以 改其中之一的值\n// error TextString := \"Hello Kay Jay!\" TextString[1] = 'T' string 值 可以 整個被替換\n// ok TextString := \"Hello Kay Jay!\" TextString = \"Hello KJ!\" 參考資料  徹底弄清Golang中[]byte與string轉換_Go語言中文網 - MdEditor  ","categories":["Golang","教學文件","新手教學","基礎","Byte 變數"],"description":"Golang 基礎: Byte 變數","excerpt":"Golang 基礎: Byte 變數","ref":"/basic/data-type/byte/","tags":["Golang","教學文件","新手教學","基礎","Byte 變數"],"title":"Byte"},{"body":"Sqrt 開根號 package main import ( \"fmt\" \"math\" ) func main() { // Square root of a integer \tres := math.Sqrt(4) // 2 \tfmt.Println(res) // Square root of a integer \t// 3 \tres = math.Sqrt(9) fmt.Println(res) // Square Root of a float \tres = math.Sqrt(30.33) // 5.5072679252057455 \tfmt.Println(res) // Square Root of a negative number \t// NaN \tres = math.Sqrt(-9) fmt.Println(res) } 參考資料  math package - math - pkg.go.dev  ","categories":["Golang","教學文件","新手教學","基礎","數學"],"description":"Golang 基礎: 數學","excerpt":"Golang 基礎: 數學","ref":"/basic/math/","tags":["Golang","教學文件","新手教學","基礎","數學"],"title":"數學"},{"body":"","categories":["Golang","教學文件","新手教學","Leetcode","問題"],"description":"Golang Leetcode 問題","excerpt":"Golang Leetcode 問題","ref":"/leetcode/question/","tags":["Golang","教學文件","新手教學","Leetcode","問題"],"title":"問題"},{"body":"","categories":["Golang","教學文件","新手教學"],"description":"","excerpt":"","ref":"/docs/","tags":["Golang","教學文件","新手教學"],"title":"教學文件"},{"body":"參考資料  GolangCode - A Library of Go Snippets  ","categories":["Golang","教學文件","新手教學","常見問題"],"description":"Golang 常見問題","excerpt":"Golang 常見問題","ref":"/question/","tags":["Golang","教學文件","新手教學","常見問題"],"title":"Golang 常見問題"},{"body":"官方  A Tour of Go  教學網站  Go 語言教學 | 線上程式語言教學練習 GoLang入門基礎: - HackMD GoLang進階語法: - HackMD GoLang 應用範例: - HackMD Learn Go with tests - learn-go-with-tests Introduction - 使用 Golang 打造 Web 應用程式  GitHub - doggy8088/build-web-application-with-golang-zhtw: 使用 Golang 打造 Web 應用程式 (正體中文版)   Go Tutorial - Tutorialspoint  範例  Go by Example 序 | LeetCode Cookbook  GitHub - halfrost/LeetCode-Go: ✅ Solutions to LeetCode by Go, 100% test coverage, runtime beats 100% / LeetCode 题解    文章  [Golang] 程式設計教學 | Michael Chen 的技術文件  Go 語言筆記(0) — 學這能幹嘛？. 「即將啟程的旅人啊，汝為何而Go?」 | by Jyue Chen | 整個程式都是我的咖啡館 | Medium   從無到有，使用 Go 開發應用程式 :: 2018 iT 邦幫忙鐵人賽  影片  Learn Go Programming - Golang Tutorial for Beginners - YouTube  ","categories":["Golang","教學文件","新手教學","資源"],"description":"Golang 資源","excerpt":"Golang 資源","ref":"/docs/resource/","tags":["Golang","教學文件","新手教學","資源"],"title":"資源"},{"body":"","categories":["Golang","教學文件","新手教學","Leetcode"],"description":"Golang Leetcode","excerpt":"Golang Leetcode","ref":"/leetcode/","tags":["Golang","教學文件","新手教學","Leetcode"],"title":"Leetcode"},{"body":"  #td-cover-block-0 { background-image: url(/hugo-background-1_hu348189a7f185b762e60e6aa110cecbb0_75733_960x540_fill_catmullrom_bottom_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/hugo-background-1_hu348189a7f185b762e60e6aa110cecbb0_75733_1920x1080_fill_catmullrom_bottom_2.png); } }  Golang for newbie Golang 菜雞踩雷學習筆記        記錄學習 Golang 遇到各種不同的系統狀況處理紀錄\n   ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: url(/hugo-background-1_hu348189a7f185b762e60e6aa110cecbb0_75733_960x540_fill_catmullrom_bottom_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: …","ref":"/","tags":"","title":"Golang for newbie"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/byte-%E8%AE%8A%E6%95%B8/","tags":"","title":"Byte 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/byte-%E8%AE%8A%E6%95%B8/","tags":"","title":"Byte 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/golang/","tags":"","title":"Golang"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/golang/","tags":"","title":"Golang"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%9F%BA%E7%A4%8E/","tags":"","title":"基礎"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%9F%BA%E7%A4%8E/","tags":"","title":"基礎"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%95%99%E5%AD%B8%E6%96%87%E4%BB%B6/","tags":"","title":"教學文件"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%95%99%E5%AD%B8%E6%96%87%E4%BB%B6/","tags":"","title":"教學文件"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8/","tags":"","title":"新手教學"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8/","tags":"","title":"新手教學"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/env-%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8/","tags":"","title":"env 環境變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/env-%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8/","tags":"","title":"env 環境變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/struct-%E8%AE%8A%E6%95%B8/","tags":"","title":"Struct 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/struct-%E8%AE%8A%E6%95%B8/","tags":"","title":"Struct 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E4%BA%82%E6%95%B8/","tags":"","title":"亂數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E4%BA%82%E6%95%B8/","tags":"","title":"亂數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%87%BD%E5%BC%8F/","tags":"","title":"函式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%87%BD%E5%BC%8F/","tags":"","title":"函式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%8C%BF%E5%90%8D%E5%87%BD%E5%BC%8F/","tags":"","title":"匿名函式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E5%BC%8F/","tags":"","title":"匿名函式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%AE%89%E8%A3%9D/","tags":"","title":"安裝"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%AE%89%E8%A3%9D/","tags":"","title":"安裝"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%95%B8%E5%AD%B8/","tags":"","title":"數學"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%95%B8%E5%AD%B8/","tags":"","title":"數學"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%99%82%E9%96%93/","tags":"","title":"時間"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%99%82%E9%96%93/","tags":"","title":"時間"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0026-remove-duplicates-from-sorted-array/","tags":"","title":"0026 - Remove Duplicates from Sorted Array"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0026-remove-duplicates-from-sorted-array/","tags":"","title":"0026 - Remove Duplicates from Sorted Array"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/leetcode/","tags":"","title":"Leetcode"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/leetcode/","tags":"","title":"Leetcode"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%95%8F%E9%A1%8C/","tags":"","title":"問題"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%95%8F%E9%A1%8C/","tags":"","title":"問題"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/operators/","tags":"","title":"Operators"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/operators/","tags":"","title":"Operators"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E4%BD%8D%E5%85%83-bits-%E9%81%8B%E7%AE%97/","tags":"","title":"位元 bits 運算"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E4%BD%8D%E5%85%83-bits-%E9%81%8B%E7%AE%97/","tags":"","title":"位元 bits 運算"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%81%8B%E7%AE%97%E5%85%83/","tags":"","title":"運算元"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%81%8B%E7%AE%97%E5%85%83/","tags":"","title":"運算元"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0003-longest-substring-without-repeating-characters/","tags":"","title":"0003 - Longest Substring Without Repeating Characters"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0003-longest-substring-without-repeating-characters/","tags":"","title":"0003 - Longest Substring Without Repeating Characters"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0004-median-of-two-sorted-arrays/","tags":"","title":"0004 - Median of Two Sorted Arrays"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0004-median-of-two-sorted-arrays/","tags":"","title":"0004 - Median of Two Sorted Arrays"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/call-by-reference/","tags":"","title":"call by reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/call-by-reference/","tags":"","title":"call by reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/call-by-value/","tags":"","title":"call by value"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/call-by-value/","tags":"","title":"call by value"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/pointer/","tags":"","title":"Pointer"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/pointer/","tags":"","title":"Pointer"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E6%8C%87%E6%A8%99/","tags":"","title":"指標"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E6%8C%87%E6%A8%99/","tags":"","title":"指標"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0002-add-two-number/","tags":"","title":"0002 - Add Two Number"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0002-add-two-number/","tags":"","title":"0002 - Add Two Number"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/linked-list/","tags":"","title":"Linked list"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/linked-list/","tags":"","title":"Linked list"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%8F%88%E8%A1%A8/","tags":"","title":"鏈表"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%8F%88%E8%A1%A8/","tags":"","title":"鏈表"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0175-combine-two-table/","tags":"","title":"0175 - Combine Two Table"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0175-combine-two-table/","tags":"","title":"0175 - Combine Two Table"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0176-second-highest-salary/","tags":"","title":"0176 - Second Highest Salary"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0176-second-highest-salary/","tags":"","title":"0176 - Second Highest Salary"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/0001-two-sum/","tags":"","title":"0001 - Two Sum"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/0001-two-sum/","tags":"","title":"0001 - Two Sum"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/for-range-%E8%BF%B4%E5%9C%88/","tags":"","title":"for range 迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/for-range-%E8%BF%B4%E5%9C%88/","tags":"","title":"for range 迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/slice-%E8%AE%8A%E6%95%B8/","tags":"","title":"Slice 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/slice-%E8%AE%8A%E6%95%B8/","tags":"","title":"Slice 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/underscore-comma/","tags":"","title":"underscore comma"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/underscore-comma/","tags":"","title":"underscore comma"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C/","tags":"","title":"常見問題"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C/","tags":"","title":"常見問題"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%BA%95%E7%B7%9A/","tags":"","title":"底線"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%BA%95%E7%B7%9A/","tags":"","title":"底線"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E8%AA%9E%E8%A8%80%E7%89%B9%E6%80%A7/","tags":"","title":"語言特性"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%AA%9E%E8%A8%80%E7%89%B9%E6%80%A7/","tags":"","title":"語言特性"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%80%B2%E9%9A%8E%E9%99%A3%E5%88%97/","tags":"","title":"進階陣列"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%80%B2%E9%9A%8E%E9%99%A3%E5%88%97/","tags":"","title":"進階陣列"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/key-value-%E9%99%A3%E5%88%97/","tags":"","title":"key-value 陣列"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/key-value-%E9%99%A3%E5%88%97/","tags":"","title":"key-value 陣列"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/map-%E8%AE%8A%E6%95%B8/","tags":"","title":"Map 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/map-%E8%AE%8A%E6%95%B8/","tags":"","title":"Map 變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/for-%E8%BF%B4%E5%9C%88/","tags":"","title":"for 迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/for-%E8%BF%B4%E5%9C%88/","tags":"","title":"for 迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E4%B8%80%E8%88%AC%E8%AE%8A%E6%95%B8/","tags":"","title":"一般變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E4%B8%80%E8%88%AC%E8%AE%8A%E6%95%B8/","tags":"","title":"一般變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%88%97%E5%8D%B0/","tags":"","title":"列印"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%88%97%E5%8D%B0/","tags":"","title":"列印"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E5%88%97%E5%8D%B0%E6%A0%BC%E5%BC%8F/","tags":"","title":"列印格式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E5%88%97%E5%8D%B0%E6%A0%BC%E5%BC%8F/","tags":"","title":"列印格式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E8%AE%8A%E6%95%B8%E9%A1%9E%E5%9E%8B/","tags":"","title":"變數類型"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%AE%8A%E6%95%B8%E9%A1%9E%E5%9E%8B/","tags":"","title":"變數類型"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E8%BF%B4%E5%9C%88/","tags":"","title":"迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%BF%B4%E5%9C%88/","tags":"","title":"迴圈"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E9%99%A3%E5%88%97%E8%AE%8A%E6%95%B8/","tags":"","title":"陣列變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E9%99%A3%E5%88%97%E8%AE%8A%E6%95%B8/","tags":"","title":"陣列變數"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/debug/","tags":"","title":"Debug"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/debug/","tags":"","title":"Debug"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E4%B8%AD%E6%96%B7%E7%A8%8B%E5%BC%8F/","tags":"","title":"中斷程式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E4%B8%AD%E6%96%B7%E7%A8%8B%E5%BC%8F/","tags":"","title":"中斷程式"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E8%B3%87%E6%BA%90/","tags":"","title":"資源"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E8%B3%87%E6%BA%90/","tags":"","title":"資源"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/%E7%92%B0%E5%A2%83/","tags":"","title":"環境"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/%E7%92%B0%E5%A2%83/","tags":"","title":"環境"}]